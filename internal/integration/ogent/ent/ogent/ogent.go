// Code generated by entc, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"
	"strings"
	"time"

	"ariga.io/ogent/internal/integration/ogent/ent"
	"ariga.io/ogent/internal/integration/ogent/ent/category"
	"ariga.io/ogent/internal/integration/ogent/ent/pet"
	"ariga.io/ogent/internal/integration/ogent/ent/schema"
	"ariga.io/ogent/internal/integration/ogent/ent/user"
	"entgo.io/ent/dialect/sql"
	"github.com/alecthomas/participle"
	"github.com/alecthomas/participle/lexer"
	"github.com/go-faster/jx"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

type Boolean bool

func (b *Boolean) Capture(values []string) error {
	*b = values[0] == "TRUE"
	return nil
}

type Select struct {
	Top        *Term             `"SELECT" [ "TOP" @@ ]`
	Distinct   bool              `[  @"DISTINCT"`
	All        bool              ` | @"ALL" ]`
	Expression *SelectExpression `@@`
	From       *From             `"FROM" @@`
	Limit      *Expression       `[ "LIMIT" @@ ]`
	Offset     *Expression       `[ "OFFSET" @@ ]`
	GroupBy    *Expression       `[ "GROUP" "BY" @@ ]`
}

type From struct {
	TableExpressions []*TableExpression `@@ { "," @@ }`
	Where            *Expression        `[ "WHERE" @@ ]`
}

type TableExpression struct {
	Table  string        `( @Ident { "." @Ident }`
	Select *Select       `  | "(" @@ ")"`
	Values []*Expression `  | "VALUES" "(" @@ { "," @@ } ")")`
	As     string        `[ "AS" @Ident ]`
}

type SelectExpression struct {
	All         bool                 `  @"*"`
	Expressions []*AliasedExpression `| @@ { "," @@ }`
}

type AliasedExpression struct {
	Expression *Expression `@@`
	As         string      `[ "AS" @Ident ]`
}

type Expression struct {
	Or []*OrCondition `@@ { "or" @@ }`
}

type OrCondition struct {
	And []*Condition `@@ { "and" @@ }`
}

type Condition struct {
	Operand *ConditionOperand `  @@`
	Not     *Condition        `| "NOT" @@`
	Exists  *Select           `| "EXISTS" "(" @@ ")"`
}

type ConditionOperand struct {
	Operand      *Operand      `@@`
	ConditionRHS *ConditionRHS `[ @@ ]`
}

type ConditionRHS struct {
	Compare *Compare `  @@`
	Is      *Is      `| "IS" @@`
	Between *Between `| "BETWEEN" @@`
	In      *In      `| "IN" "(" @@ ")"`
	Like    *Like    `| "LIKE" @@`
}

type Compare struct {
	Operator string         `@( "ne" | "le" | "ge" | "eq" | "lt" | "gt")`
	Operand  *Operand       `(  @@`
	Select   *CompareSelect ` | @@ )`
}

type CompareSelect struct {
	All    bool    `(  @"ALL"`
	Any    bool    ` | @"ANY"`
	Some   bool    ` | @"SOME" )`
	Select *Select `"(" @@ ")"`
}

type Like struct {
	Not     bool     `[ @"NOT" ]`
	Operand *Operand `@@`
}

type Is struct {
	Not          bool     `[ @"NOT" ]`
	Null         bool     `( @"NULL"`
	DistinctFrom *Operand `  | "DISTINCT" "FROM" @@ )`
}

type Between struct {
	Start *Operand `@@`
	End   *Operand `"and" @@`
}

type In struct {
	Select      *Select       `  @@`
	Expressions []*Expression `| @@ { "," @@ }`
}

type Operand struct {
	Summand []*Summand `@@ { "|" "|" @@ }`
}

type Summand struct {
	LHS *Factor `@@`
	Op  string  `[ @("+" | "-")`
	RHS *Factor `  @@ ]`
}

type Factor struct {
	LHS *Term  `@@`
	Op  string `[ @("*" | "/" | "%")`
	RHS *Term  `  @@ ]`
}

type Term struct {
	Select        *Select     `  @@`
	Value         *Value      `| @@`
	SymbolRef     *SymbolRef  `| @@`
	SubExpression *Expression `| "(" @@ ")"`
}

type SymbolRef struct {
	Symbol     string        `@Ident @{ "." Ident }`
	Parameters []*Expression `[ "(" @@ { "," @@ } ")" ]`
}

type Value struct {
	Wildcard bool       `(  @"*"`
	Number   *float64   ` | @Number`
	String   *string    ` | @String`
	Boolean  *Boolean   ` | @("TRUE" | "FALSE")`
	Null     bool       ` | @"NULL"`
	Date     *time.Time ` | @Date`
	Array    *Array     ` | @@ )`
}

type Array struct {
	Expressions []*Expression `"(" @@ { "," @@ } ")"`
}

func ParseExpression(exp *Expression, s *sql.Selector) {
	i := 0
	len := len(exp.Or)
	for i < len { //OR
		parseAndExpression(exp.Or[i], s)
		i++
		if i < len {
			s.Or()
		}
	}
}

func parseAndExpression(and *OrCondition, s *sql.Selector) {
	for _, c := range and.And {
		if c.Operand != nil {
			addPredicate(c, s)
		} else if c.Not != nil {
			addPredicate(c.Not, s)
		}
	}
}

func addPredicate(c *Condition, s *sql.Selector) {
	con := c.Operand.ConditionRHS
	if con != nil {
		op := con.Compare.Operator
		col := getColumn(c.Operand)
		v := getOperand(c.Operand.ConditionRHS.Compare.Operand, s)
		switch op {
		case "eq":
			s.Where(sql.EQ(s.C(col), v)) //Equal
		case "ne":
			s.Where(sql.NEQ(s.C(col), v)) //Not equal
		case "gt":
			s.Where(sql.GT(s.C(col), v)) //Greater than
		case "ge":
			s.Where(sql.GTE(s.C(col), v)) //Greater than or equal
		case "lt":
			s.Where(sql.LT(s.C(col), v)) //Less than
		case "le":
			s.Where(sql.LTE(s.C(col), v)) //Less than or equal
		}
	} else {
		v := getOperand(c.Operand.Operand, s).(*Array)
		for _, i := range v.Expressions {
			ParseExpression(i, s)
		}
	}
}

func getColumn(col *ConditionOperand) string {
	return getOperand(col.Operand, nil).(string)
}

func getOperand(op *Operand, s *sql.Selector) interface{} {
	for _, su := range op.Summand {
		return getValue(su, s)
	}
	return nil
}

func getValue(su *Summand, s *sql.Selector) interface{} {
	if su.LHS.LHS.Value != nil {
		v := su.LHS.LHS.Value
		if v.String != nil {
			return v.String
		} else if v.Number != nil {
			return v.Number
		} else if v.Date != nil {
			return v.Date
		} else if v.Array != nil {
			return v.Array
		}
	} else {
		return su.LHS.LHS.SymbolRef.Symbol
	}
	return nil
}

var (
	sqlLexer = lexer.Must(lexer.Regexp(`(\s+)` +
		`|(?P<Keyword>(?i)SELECT|FROM|TOP|DISTINCT|ALL|WHERE|GROUP|BY|HAVING|UNION|MINUS|EXCEPT|INTERSECT|ORDER|LIMIT|OFFSET|TRUE|FALSE|NULL|IS|NOT|ANY|SOME|BETWEEN|and|or|LIKE|AS|IN)` +
		`|(?P<Ident>[a-zA-Z_][a-zA-Z0-9_]*)` +
		`|(?P<Date>\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(\.\d+)?([zZ]|(\+|-)(\d{2}):(\d{2}))` +
		`|(?P<Number>[-+]?\d*\.?\d+([eE][-+]?\d+)?)` +
		`|(?P<String>'[^']*'|"[^"]*")` +
		`|(?P<Operators><>|!=|<=|>=|[-+*/%,.()=<>]|eq|ne|gt|ge|lt|le)`,
	))
	SqlParser = participle.MustBuild(
		&Expression{},
		participle.Lexer(sqlLexer),
		participle.Unquote("String"),
		participle.CaseInsensitive("Keyword"),
	)
)

// CreateCategory handles POST /categories requests.
func (h *OgentHandler) CreateCategory(ctx context.Context, req CreateCategoryReq) (CreateCategoryRes, error) {
	b := h.client.Category.Create()
	// Add all fields.
	b.SetName(req.Name)
	// Add all edges.
	b.AddPetIDs(req.Pets...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Category.Query().Where(category.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCategoryCreate(e), nil
}

// ReadCategory handles GET /categories/{id} requests.
func (h *OgentHandler) ReadCategory(ctx context.Context, params ReadCategoryParams) (ReadCategoryRes, error) {
	q := h.client.Category.Query().Where(category.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCategoryRead(e), nil
}

// UpdateCategory handles PATCH /categories/{id} requests.
func (h *OgentHandler) UpdateCategory(ctx context.Context, req UpdateCategoryReq, params UpdateCategoryParams) (UpdateCategoryRes, error) {
	b := h.client.Category.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	// Add all edges.
	b.ClearPets().AddPetIDs(req.Pets...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Category.Query().Where(category.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCategoryUpdate(e), nil
}

// DeleteCategory handles DELETE /categories/{id} requests.
func (h *OgentHandler) DeleteCategory(ctx context.Context, params DeleteCategoryParams) (DeleteCategoryRes, error) {
	err := h.client.Category.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteCategoryNoContent), nil

}

// ListCategory handles GET /categories requests.
func (h *OgentHandler) ListCategory(ctx context.Context, params ListCategoryParams) (ListCategoryRes, error) {
	q := h.client.Category.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	//Sort the fetched data in either ascending or descending
	if v, ok := params.OrderBy.Get(); ok {
		for _, p := range strings.Split(v, ",") {
			f := strings.Fields(p)
			column := f[0]
			if len(f) > 1 && f[1] == "desc" {
				q.Order(ent.Desc(column))
			} else {
				q.Order(ent.Asc(column))
			}
		}
	}

	//Filter operations
	if v, ok := params.Filter.Get(); ok {
		exp := &Expression{}
		err := SqlParser.ParseString(v, exp)
		if err != nil {
			return &R400{
				Code:   http.StatusBadRequest,
				Status: http.StatusText(http.StatusBadRequest),
				Errors: rawError(err),
			}, nil
		} else {
			//parse filter
			q.Where(func(s *sql.Selector) {
				ParseExpression(exp, s)
			})
		}
	}

	//run the query
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCategoryLists(es)
	return (*ListCategoryOKApplicationJSON)(&r), nil
}

// ListCategoryPets handles GET /categories/{id}/pets requests.
func (h *OgentHandler) ListCategoryPets(ctx context.Context, params ListCategoryPetsParams) (ListCategoryPetsRes, error) {
	q := h.client.Category.Query().Where(category.IDEQ(params.ID)).QueryPets()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	//Sort the fetched data in either ascending or descending
	if v, ok := params.OrderBy.Get(); ok {
		for _, p := range strings.Split(v, ",") {
			f := strings.Fields(p)
			column := f[0]
			if len(f) > 1 && f[1] == "desc" {
				q.Order(ent.Desc(column))
			} else {
				q.Order(ent.Asc(column))
			}
		}
	}

	//run the query
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCategoryPetsLists(es)
	return (*ListCategoryPetsOKApplicationJSON)(&r), nil
}

// CreatePet handles POST /pets requests.
func (h *OgentHandler) CreatePet(ctx context.Context, req CreatePetReq) (CreatePetRes, error) {
	b := h.client.Pet.Create()
	// Add all fields.
	b.SetName(req.Name)
	if v, ok := req.Weight.Get(); ok {
		b.SetWeight(v)
	}
	if v, ok := req.Birthday.Get(); ok {
		b.SetBirthday(v)
	}
	// Add all edges.
	b.AddCategoryIDs(req.Categories...)
	b.SetOwnerID(req.Owner)
	b.AddFriendIDs(req.Friends...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Pet.Query().Where(pet.ID(e.ID))
	// Eager load edges that are required on create operation.
	q.WithCategories().WithOwner()
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewPetCreate(e), nil
}

// DeletePet handles DELETE /pets/{id} requests.
func (h *OgentHandler) DeletePet(ctx context.Context, params DeletePetParams) (DeletePetRes, error) {
	err := h.client.Pet.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeletePetNoContent), nil

}

// ListPet handles GET /pets requests.
func (h *OgentHandler) ListPet(ctx context.Context, params ListPetParams) (ListPetRes, error) {
	q := h.client.Pet.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	//Sort the fetched data in either ascending or descending
	if v, ok := params.OrderBy.Get(); ok {
		for _, p := range strings.Split(v, ",") {
			f := strings.Fields(p)
			column := f[0]
			if len(f) > 1 && f[1] == "desc" {
				q.Order(ent.Desc(column))
			} else {
				q.Order(ent.Asc(column))
			}
		}
	}

	//Filter operations
	if v, ok := params.Filter.Get(); ok {
		exp := &Expression{}
		err := SqlParser.ParseString(v, exp)
		if err != nil {
			return &R400{
				Code:   http.StatusBadRequest,
				Status: http.StatusText(http.StatusBadRequest),
				Errors: rawError(err),
			}, nil
		} else {
			//parse filter
			q.Where(func(s *sql.Selector) {
				ParseExpression(exp, s)
			})
		}
	}

	//run the query
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewPetLists(es)
	return (*ListPetOKApplicationJSON)(&r), nil
}

// ReadPet handles GET /pets/{id} requests.
func (h *OgentHandler) ReadPet(ctx context.Context, params ReadPetParams) (ReadPetRes, error) {
	q := h.client.Pet.Query().Where(pet.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewPetRead(e), nil
}

// UpdatePet handles PATCH /pets/{id} requests.
func (h *OgentHandler) UpdatePet(ctx context.Context, req UpdatePetReq, params UpdatePetParams) (UpdatePetRes, error) {
	b := h.client.Pet.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Weight.Get(); ok {
		b.SetWeight(v)
	}
	if v, ok := req.Birthday.Get(); ok {
		b.SetBirthday(v)
	}
	// Add all edges.
	b.ClearCategories().AddCategoryIDs(req.Categories...)
	if v, ok := req.Owner.Get(); ok {
		b.SetOwnerID(v)
	}
	b.ClearFriends().AddFriendIDs(req.Friends...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Pet.Query().Where(pet.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewPetUpdate(e), nil
}

// ListPetCategories handles GET /pets/{id}/categories requests.
func (h *OgentHandler) ListPetCategories(ctx context.Context, params ListPetCategoriesParams) (ListPetCategoriesRes, error) {
	q := h.client.Pet.Query().Where(pet.IDEQ(params.ID)).QueryCategories()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	//Sort the fetched data in either ascending or descending
	if v, ok := params.OrderBy.Get(); ok {
		for _, p := range strings.Split(v, ",") {
			f := strings.Fields(p)
			column := f[0]
			if len(f) > 1 && f[1] == "desc" {
				q.Order(ent.Desc(column))
			} else {
				q.Order(ent.Asc(column))
			}
		}
	}

	//run the query
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewPetCategoriesLists(es)
	return (*ListPetCategoriesOKApplicationJSON)(&r), nil
}

// ReadPetOwner handles GET /pets/{id}/owner requests.
func (h *OgentHandler) ReadPetOwner(ctx context.Context, params ReadPetOwnerParams) (ReadPetOwnerRes, error) {
	q := h.client.Pet.Query().Where(pet.IDEQ(params.ID)).QueryOwner()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewPetOwnerRead(e), nil
}

// ListPetFriends handles GET /pets/{id}/friends requests.
func (h *OgentHandler) ListPetFriends(ctx context.Context, params ListPetFriendsParams) (ListPetFriendsRes, error) {
	q := h.client.Pet.Query().Where(pet.IDEQ(params.ID)).QueryFriends()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	//Sort the fetched data in either ascending or descending
	if v, ok := params.OrderBy.Get(); ok {
		for _, p := range strings.Split(v, ",") {
			f := strings.Fields(p)
			column := f[0]
			if len(f) > 1 && f[1] == "desc" {
				q.Order(ent.Desc(column))
			} else {
				q.Order(ent.Asc(column))
			}
		}
	}

	//run the query
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewPetFriendsLists(es)
	return (*ListPetFriendsOKApplicationJSON)(&r), nil
}

// CreateUser handles POST /users requests.
func (h *OgentHandler) CreateUser(ctx context.Context, req CreateUserReq) (CreateUserRes, error) {
	b := h.client.User.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetAge(req.Age)
	b.SetFavoriteCatBreed(user.FavoriteCatBreed(req.FavoriteCatBreed))
	if v, ok := req.FavoriteDogBreed.Get(); ok {
		b.SetFavoriteDogBreed(user.FavoriteDogBreed(v))
	}
	if v, ok := req.FavoriteFishBreed.Get(); ok {
		b.SetFavoriteFishBreed(schema.FishBreed(v))
	}
	// Add all edges.
	b.AddPetIDs(req.Pets...)
	if v, ok := req.BestFriend.Get(); ok {
		b.SetBestFriendID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserCreate(e), nil
}

// ReadUser handles GET /users/{id} requests.
func (h *OgentHandler) ReadUser(ctx context.Context, params ReadUserParams) (ReadUserRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewUserRead(e), nil
}

// UpdateUser handles PATCH /users/{id} requests.
func (h *OgentHandler) UpdateUser(ctx context.Context, req UpdateUserReq, params UpdateUserParams) (UpdateUserRes, error) {
	b := h.client.User.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Age.Get(); ok {
		b.SetAge(v)
	}
	if v, ok := req.FavoriteCatBreed.Get(); ok {
		b.SetFavoriteCatBreed(user.FavoriteCatBreed(v))
	}
	if v, ok := req.FavoriteDogBreed.Get(); ok {
		b.SetFavoriteDogBreed(user.FavoriteDogBreed(v))
	}
	if v, ok := req.FavoriteFishBreed.Get(); ok {
		b.SetFavoriteFishBreed(schema.FishBreed(v))
	}
	// Add all edges.
	b.ClearPets().AddPetIDs(req.Pets...)
	if v, ok := req.BestFriend.Get(); ok {
		b.SetBestFriendID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserUpdate(e), nil
}

// DeleteUser handles DELETE /users/{id} requests.
func (h *OgentHandler) DeleteUser(ctx context.Context, params DeleteUserParams) (DeleteUserRes, error) {
	err := h.client.User.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteUserNoContent), nil

}

// ListUser handles GET /users requests.
func (h *OgentHandler) ListUser(ctx context.Context, params ListUserParams) (ListUserRes, error) {
	q := h.client.User.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	//Sort the fetched data in either ascending or descending
	if v, ok := params.OrderBy.Get(); ok {
		for _, p := range strings.Split(v, ",") {
			f := strings.Fields(p)
			column := f[0]
			if len(f) > 1 && f[1] == "desc" {
				q.Order(ent.Desc(column))
			} else {
				q.Order(ent.Asc(column))
			}
		}
	}

	//Filter operations
	if v, ok := params.Filter.Get(); ok {
		exp := &Expression{}
		err := SqlParser.ParseString(v, exp)
		if err != nil {
			return &R400{
				Code:   http.StatusBadRequest,
				Status: http.StatusText(http.StatusBadRequest),
				Errors: rawError(err),
			}, nil
		} else {
			//parse filter
			q.Where(func(s *sql.Selector) {
				ParseExpression(exp, s)
			})
		}
	}

	//run the query
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserLists(es)
	return (*ListUserOKApplicationJSON)(&r), nil
}

// ListUserPets handles GET /users/{id}/pets requests.
func (h *OgentHandler) ListUserPets(ctx context.Context, params ListUserPetsParams) (ListUserPetsRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryPets()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	//Sort the fetched data in either ascending or descending
	if v, ok := params.OrderBy.Get(); ok {
		for _, p := range strings.Split(v, ",") {
			f := strings.Fields(p)
			column := f[0]
			if len(f) > 1 && f[1] == "desc" {
				q.Order(ent.Desc(column))
			} else {
				q.Order(ent.Asc(column))
			}
		}
	}

	//run the query
	es, err := q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage).All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserPetsLists(es)
	return (*ListUserPetsOKApplicationJSON)(&r), nil
}

// ReadUserBestFriend handles GET /users/{id}/best-friend requests.
func (h *OgentHandler) ReadUserBestFriend(ctx context.Context, params ReadUserBestFriendParams) (ReadUserBestFriendRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryBestFriend()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewUserBestFriendRead(e), nil
}
