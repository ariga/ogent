// Code generated by ogen, DO NOT EDIT.

package ogent

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/big"
	"math/bits"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = bits.LeadingZeros64
	_ = big.Rat{}
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = attribute.KeyValue{}
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
	_ = codes.Unset
)

// Encode implements json.Marshaler.
func (s CategoryCreate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"readonly\"" + ":")
		e.Str(s.Readonly)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCategoryCreate = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes CategoryCreate from json.
func (s *CategoryCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Readonly = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryCreate) {
					name = jsonFieldsNameOfCategoryCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CategoryList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"readonly\"" + ":")
		e.Str(s.Readonly)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCategoryList = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes CategoryList from json.
func (s *CategoryList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Readonly = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryList) {
					name = jsonFieldsNameOfCategoryList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CategoryPetsList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCategoryPetsList = [4]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
}

// Decode decodes CategoryPetsList from json.
func (s *CategoryPetsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryPetsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryPetsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryPetsList) {
					name = jsonFieldsNameOfCategoryPetsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CategoryRead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"readonly\"" + ":")
		e.Str(s.Readonly)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCategoryRead = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes CategoryRead from json.
func (s *CategoryRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Readonly = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryRead) {
					name = jsonFieldsNameOfCategoryRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CategoryUpdate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"readonly\"" + ":")
		e.Str(s.Readonly)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCategoryUpdate = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes CategoryUpdate from json.
func (s *CategoryUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Readonly = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryUpdate) {
					name = jsonFieldsNameOfCategoryUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CreateCategoryReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Pets != nil {
			e.Comma()
		}
		if s.Pets != nil {
			e.RawStr("\"pets\"" + ":")
			e.ArrStart()
			if len(s.Pets) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Pets[0]
					e.Int(elem)
				}
				for _, elem := range s.Pets[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCreateCategoryReq = [2]string{
	0: "name",
	1: "pets",
}

// Decode decodes CreateCategoryReq from json.
func (s *CreateCategoryReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCategoryReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "pets":
			if err := func() error {
				s.Pets = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Pets = append(s.Pets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateCategoryReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateCategoryReq) {
					name = jsonFieldsNameOfCreateCategoryReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CreatePetReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Categories != nil {
			e.Comma()
		}
		if s.Categories != nil {
			e.RawStr("\"categories\"" + ":")
			e.ArrStart()
			if len(s.Categories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Categories[0]
					e.Int(elem)
				}
				for _, elem := range s.Categories[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		e.Int(s.Owner)
	}
	{
		if s.Friends != nil {
			e.Comma()
		}
		if s.Friends != nil {
			e.RawStr("\"friends\"" + ":")
			e.ArrStart()
			if len(s.Friends) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Friends[0]
					e.Int(elem)
				}
				for _, elem := range s.Friends[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCreatePetReq = [6]string{
	0: "name",
	1: "weight",
	2: "birthday",
	3: "categories",
	4: "owner",
	5: "friends",
}

// Decode decodes CreatePetReq from json.
func (s *CreatePetReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePetReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "categories":
			if err := func() error {
				s.Categories = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Owner = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "friends":
			if err := func() error {
				s.Friends = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Friends = append(s.Friends, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friends\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreatePetReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatePetReq) {
					name = jsonFieldsNameOfCreatePetReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CreateUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"age\"" + ":")
		e.Int(s.Age)
	}
	{
		e.Comma()

		e.RawStr("\"favorite_cat_breed\"" + ":")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.Comma()
		}
		if s.FavoriteDogBreed.Set {
			e.RawStr("\"favorite_dog_breed\"" + ":")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.Comma()
		}
		if s.FavoriteFishBreed.Set {
			e.RawStr("\"favorite_fish_breed\"" + ":")
			s.FavoriteFishBreed.Encode(e)
		}
	}
	{
		if s.Pets != nil {
			e.Comma()
		}
		if s.Pets != nil {
			e.RawStr("\"pets\"" + ":")
			e.ArrStart()
			if len(s.Pets) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Pets[0]
					e.Int(elem)
				}
				for _, elem := range s.Pets[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.BestFriend.Set {
			e.Comma()
		}
		if s.BestFriend.Set {
			e.RawStr("\"best_friend\"" + ":")
			s.BestFriend.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCreateUserReq = [7]string{
	0: "name",
	1: "age",
	2: "favorite_cat_breed",
	3: "favorite_dog_breed",
	4: "favorite_fish_breed",
	5: "pets",
	6: "best_friend",
}

// Decode decodes CreateUserReq from json.
func (s *CreateUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Age = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		case "pets":
			if err := func() error {
				s.Pets = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Pets = append(s.Pets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pets\"")
			}
		case "best_friend":
			if err := func() error {
				s.BestFriend.Reset()
				if err := s.BestFriend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"best_friend\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserReq) {
					name = jsonFieldsNameOfCreateUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes CreateUserReqFavoriteCatBreed as json.
func (s CreateUserReqFavoriteCatBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CreateUserReqFavoriteCatBreed from json.
func (s *CreateUserReqFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserReqFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserReqFavoriteCatBreed(v) {
	case CreateUserReqFavoriteCatBreedSiamese:
		*s = CreateUserReqFavoriteCatBreedSiamese
	case CreateUserReqFavoriteCatBreedBengal:
		*s = CreateUserReqFavoriteCatBreedBengal
	case CreateUserReqFavoriteCatBreedLion:
		*s = CreateUserReqFavoriteCatBreedLion
	case CreateUserReqFavoriteCatBreedTiger:
		*s = CreateUserReqFavoriteCatBreedTiger
	case CreateUserReqFavoriteCatBreedLeopard:
		*s = CreateUserReqFavoriteCatBreedLeopard
	case CreateUserReqFavoriteCatBreedOther:
		*s = CreateUserReqFavoriteCatBreedOther
	default:
		*s = CreateUserReqFavoriteCatBreed(v)
	}

	return nil
}

// Encode encodes CreateUserReqFavoriteDogBreed as json.
func (s CreateUserReqFavoriteDogBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CreateUserReqFavoriteDogBreed from json.
func (s *CreateUserReqFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserReqFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserReqFavoriteDogBreed(v) {
	case CreateUserReqFavoriteDogBreedKuro:
		*s = CreateUserReqFavoriteDogBreedKuro
	default:
		*s = CreateUserReqFavoriteDogBreed(v)
	}

	return nil
}

// Encode encodes CreateUserReqFavoriteFishBreed as json.
func (s CreateUserReqFavoriteFishBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CreateUserReqFavoriteFishBreed from json.
func (s *CreateUserReqFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserReqFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserReqFavoriteFishBreed(v) {
	case CreateUserReqFavoriteFishBreedGold:
		*s = CreateUserReqFavoriteFishBreedGold
	case CreateUserReqFavoriteFishBreedKoi:
		*s = CreateUserReqFavoriteFishBreedKoi
	case CreateUserReqFavoriteFishBreedShark:
		*s = CreateUserReqFavoriteFishBreedShark
	default:
		*s = CreateUserReqFavoriteFishBreed(v)
	}

	return nil
}

// Encode encodes ListCategoryOKApplicationJSON as json.
func (s ListCategoryOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CategoryList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListCategoryOKApplicationJSON from json.
func (s *ListCategoryOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListCategoryOKApplicationJSON to nil")
	}
	var unwrapped []CategoryList
	if err := func() error {
		unwrapped = make([]CategoryList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CategoryList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListCategoryOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListCategoryPetsOKApplicationJSON as json.
func (s ListCategoryPetsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CategoryPetsList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListCategoryPetsOKApplicationJSON from json.
func (s *ListCategoryPetsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListCategoryPetsOKApplicationJSON to nil")
	}
	var unwrapped []CategoryPetsList
	if err := func() error {
		unwrapped = make([]CategoryPetsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CategoryPetsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListCategoryPetsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListPetCategoriesOKApplicationJSON as json.
func (s ListPetCategoriesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PetCategoriesList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListPetCategoriesOKApplicationJSON from json.
func (s *ListPetCategoriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPetCategoriesOKApplicationJSON to nil")
	}
	var unwrapped []PetCategoriesList
	if err := func() error {
		unwrapped = make([]PetCategoriesList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PetCategoriesList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListPetCategoriesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListPetFriendsOKApplicationJSON as json.
func (s ListPetFriendsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PetFriendsList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListPetFriendsOKApplicationJSON from json.
func (s *ListPetFriendsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPetFriendsOKApplicationJSON to nil")
	}
	var unwrapped []PetFriendsList
	if err := func() error {
		unwrapped = make([]PetFriendsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PetFriendsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListPetFriendsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListPetOKApplicationJSON as json.
func (s ListPetOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PetList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListPetOKApplicationJSON from json.
func (s *ListPetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPetOKApplicationJSON to nil")
	}
	var unwrapped []PetList
	if err := func() error {
		unwrapped = make([]PetList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PetList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListPetOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListUserOKApplicationJSON as json.
func (s ListUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []UserList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListUserOKApplicationJSON from json.
func (s *ListUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserOKApplicationJSON to nil")
	}
	var unwrapped []UserList
	if err := func() error {
		unwrapped = make([]UserList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ListUserPetsOKApplicationJSON as json.
func (s ListUserPetsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []UserPetsList(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ListUserPetsOKApplicationJSON from json.
func (s *ListUserPetsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserPetsOKApplicationJSON to nil")
	}
	var unwrapped []UserPetsList
	if err := func() error {
		unwrapped = make([]UserPetsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserPetsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserPetsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes CreateUserReqFavoriteDogBreed as json.
func (o OptCreateUserReqFavoriteDogBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateUserReqFavoriteDogBreed from json.
func (o *OptCreateUserReqFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateUserReqFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes CreateUserReqFavoriteFishBreed as json.
func (o OptCreateUserReqFavoriteFishBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateUserReqFavoriteFishBreed from json.
func (o *OptCreateUserReqFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateUserReqFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Writer, format func(*jx.Writer, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// Encode encodes PetCreateOwnerFavoriteDogBreed as json.
func (o OptPetCreateOwnerFavoriteDogBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PetCreateOwnerFavoriteDogBreed from json.
func (o *OptPetCreateOwnerFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPetCreateOwnerFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes PetCreateOwnerFavoriteFishBreed as json.
func (o OptPetCreateOwnerFavoriteFishBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PetCreateOwnerFavoriteFishBreed from json.
func (o *OptPetCreateOwnerFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPetCreateOwnerFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes PetOwnerReadFavoriteDogBreed as json.
func (o OptPetOwnerReadFavoriteDogBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PetOwnerReadFavoriteDogBreed from json.
func (o *OptPetOwnerReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPetOwnerReadFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes PetOwnerReadFavoriteFishBreed as json.
func (o OptPetOwnerReadFavoriteFishBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PetOwnerReadFavoriteFishBreed from json.
func (o *OptPetOwnerReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPetOwnerReadFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// Encode encodes UpdateUserReqFavoriteCatBreed as json.
func (o OptUpdateUserReqFavoriteCatBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserReqFavoriteCatBreed from json.
func (o *OptUpdateUserReqFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserReqFavoriteCatBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes UpdateUserReqFavoriteDogBreed as json.
func (o OptUpdateUserReqFavoriteDogBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserReqFavoriteDogBreed from json.
func (o *OptUpdateUserReqFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserReqFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes UpdateUserReqFavoriteFishBreed as json.
func (o OptUpdateUserReqFavoriteFishBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserReqFavoriteFishBreed from json.
func (o *OptUpdateUserReqFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserReqFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes UserBestFriendReadFavoriteDogBreed as json.
func (o OptUserBestFriendReadFavoriteDogBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserBestFriendReadFavoriteDogBreed from json.
func (o *OptUserBestFriendReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserBestFriendReadFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes UserBestFriendReadFavoriteFishBreed as json.
func (o OptUserBestFriendReadFavoriteFishBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserBestFriendReadFavoriteFishBreed from json.
func (o *OptUserBestFriendReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserBestFriendReadFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes UserCreateFavoriteDogBreed as json.
func (o OptUserCreateFavoriteDogBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserCreateFavoriteDogBreed from json.
func (o *OptUserCreateFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserCreateFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes UserCreateFavoriteFishBreed as json.
func (o OptUserCreateFavoriteFishBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserCreateFavoriteFishBreed from json.
func (o *OptUserCreateFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserCreateFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes UserListFavoriteDogBreed as json.
func (o OptUserListFavoriteDogBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserListFavoriteDogBreed from json.
func (o *OptUserListFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserListFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes UserListFavoriteFishBreed as json.
func (o OptUserListFavoriteFishBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserListFavoriteFishBreed from json.
func (o *OptUserListFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserListFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes UserReadFavoriteDogBreed as json.
func (o OptUserReadFavoriteDogBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserReadFavoriteDogBreed from json.
func (o *OptUserReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserReadFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes UserReadFavoriteFishBreed as json.
func (o OptUserReadFavoriteFishBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserReadFavoriteFishBreed from json.
func (o *OptUserReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserReadFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes UserUpdateFavoriteDogBreed as json.
func (o OptUserUpdateFavoriteDogBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserUpdateFavoriteDogBreed from json.
func (o *OptUserUpdateFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserUpdateFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode encodes UserUpdateFavoriteFishBreed as json.
func (o OptUserUpdateFavoriteFishBreed) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserUpdateFavoriteFishBreed from json.
func (o *OptUserUpdateFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserUpdateFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// Encode implements json.Marshaler.
func (s PetCategoriesList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"readonly\"" + ":")
		e.Str(s.Readonly)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetCategoriesList = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes PetCategoriesList from json.
func (s *PetCategoriesList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCategoriesList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Readonly = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetCategoriesList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCategoriesList) {
					name = jsonFieldsNameOfPetCategoriesList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetCreate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Categories != nil {
			e.Comma()
		}
		if s.Categories != nil {
			e.RawStr("\"categories\"" + ":")
			e.ArrStart()
			if len(s.Categories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Categories[0]
					elem.Encode(e)
				}
				for _, elem := range s.Categories[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetCreate = [6]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "categories",
	5: "owner",
}

// Decode decodes PetCreate from json.
func (s *PetCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "categories":
			if err := func() error {
				s.Categories = make([]PetCreateCategories, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PetCreateCategories
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCreate) {
					name = jsonFieldsNameOfPetCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetCreateCategories) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"readonly\"" + ":")
		e.Str(s.Readonly)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetCreateCategories = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes PetCreateCategories from json.
func (s *PetCreateCategories) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateCategories to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Readonly = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetCreateCategories")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCreateCategories) {
					name = jsonFieldsNameOfPetCreateCategories[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetCreateOwner) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"age\"" + ":")
		e.Int(s.Age)
	}
	{
		e.Comma()

		e.RawStr("\"favorite_cat_breed\"" + ":")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.Comma()
		}
		if s.FavoriteDogBreed.Set {
			e.RawStr("\"favorite_dog_breed\"" + ":")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.Comma()
		}
		if s.FavoriteFishBreed.Set {
			e.RawStr("\"favorite_fish_breed\"" + ":")
			s.FavoriteFishBreed.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetCreateOwner = [6]string{
	0: "id",
	1: "name",
	2: "age",
	3: "favorite_cat_breed",
	4: "favorite_dog_breed",
	5: "favorite_fish_breed",
}

// Decode decodes PetCreateOwner from json.
func (s *PetCreateOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateOwner to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Age = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetCreateOwner")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCreateOwner) {
					name = jsonFieldsNameOfPetCreateOwner[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PetCreateOwnerFavoriteCatBreed as json.
func (s PetCreateOwnerFavoriteCatBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PetCreateOwnerFavoriteCatBreed from json.
func (s *PetCreateOwnerFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateOwnerFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetCreateOwnerFavoriteCatBreed(v) {
	case PetCreateOwnerFavoriteCatBreedSiamese:
		*s = PetCreateOwnerFavoriteCatBreedSiamese
	case PetCreateOwnerFavoriteCatBreedBengal:
		*s = PetCreateOwnerFavoriteCatBreedBengal
	case PetCreateOwnerFavoriteCatBreedLion:
		*s = PetCreateOwnerFavoriteCatBreedLion
	case PetCreateOwnerFavoriteCatBreedTiger:
		*s = PetCreateOwnerFavoriteCatBreedTiger
	case PetCreateOwnerFavoriteCatBreedLeopard:
		*s = PetCreateOwnerFavoriteCatBreedLeopard
	case PetCreateOwnerFavoriteCatBreedOther:
		*s = PetCreateOwnerFavoriteCatBreedOther
	default:
		*s = PetCreateOwnerFavoriteCatBreed(v)
	}

	return nil
}

// Encode encodes PetCreateOwnerFavoriteDogBreed as json.
func (s PetCreateOwnerFavoriteDogBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PetCreateOwnerFavoriteDogBreed from json.
func (s *PetCreateOwnerFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateOwnerFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetCreateOwnerFavoriteDogBreed(v) {
	case PetCreateOwnerFavoriteDogBreedKuro:
		*s = PetCreateOwnerFavoriteDogBreedKuro
	default:
		*s = PetCreateOwnerFavoriteDogBreed(v)
	}

	return nil
}

// Encode encodes PetCreateOwnerFavoriteFishBreed as json.
func (s PetCreateOwnerFavoriteFishBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PetCreateOwnerFavoriteFishBreed from json.
func (s *PetCreateOwnerFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateOwnerFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetCreateOwnerFavoriteFishBreed(v) {
	case PetCreateOwnerFavoriteFishBreedGold:
		*s = PetCreateOwnerFavoriteFishBreedGold
	case PetCreateOwnerFavoriteFishBreedKoi:
		*s = PetCreateOwnerFavoriteFishBreedKoi
	case PetCreateOwnerFavoriteFishBreedShark:
		*s = PetCreateOwnerFavoriteFishBreedShark
	default:
		*s = PetCreateOwnerFavoriteFishBreed(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetFriendsList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetFriendsList = [4]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
}

// Decode decodes PetFriendsList from json.
func (s *PetFriendsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetFriendsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetFriendsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetFriendsList) {
					name = jsonFieldsNameOfPetFriendsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetList = [4]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
}

// Decode decodes PetList from json.
func (s *PetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetList) {
					name = jsonFieldsNameOfPetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetOwnerRead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"age\"" + ":")
		e.Int(s.Age)
	}
	{
		e.Comma()

		e.RawStr("\"favorite_cat_breed\"" + ":")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.Comma()
		}
		if s.FavoriteDogBreed.Set {
			e.RawStr("\"favorite_dog_breed\"" + ":")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.Comma()
		}
		if s.FavoriteFishBreed.Set {
			e.RawStr("\"favorite_fish_breed\"" + ":")
			s.FavoriteFishBreed.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetOwnerRead = [6]string{
	0: "id",
	1: "name",
	2: "age",
	3: "favorite_cat_breed",
	4: "favorite_dog_breed",
	5: "favorite_fish_breed",
}

// Decode decodes PetOwnerRead from json.
func (s *PetOwnerRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetOwnerRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Age = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetOwnerRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetOwnerRead) {
					name = jsonFieldsNameOfPetOwnerRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PetOwnerReadFavoriteCatBreed as json.
func (s PetOwnerReadFavoriteCatBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PetOwnerReadFavoriteCatBreed from json.
func (s *PetOwnerReadFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetOwnerReadFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetOwnerReadFavoriteCatBreed(v) {
	case PetOwnerReadFavoriteCatBreedSiamese:
		*s = PetOwnerReadFavoriteCatBreedSiamese
	case PetOwnerReadFavoriteCatBreedBengal:
		*s = PetOwnerReadFavoriteCatBreedBengal
	case PetOwnerReadFavoriteCatBreedLion:
		*s = PetOwnerReadFavoriteCatBreedLion
	case PetOwnerReadFavoriteCatBreedTiger:
		*s = PetOwnerReadFavoriteCatBreedTiger
	case PetOwnerReadFavoriteCatBreedLeopard:
		*s = PetOwnerReadFavoriteCatBreedLeopard
	case PetOwnerReadFavoriteCatBreedOther:
		*s = PetOwnerReadFavoriteCatBreedOther
	default:
		*s = PetOwnerReadFavoriteCatBreed(v)
	}

	return nil
}

// Encode encodes PetOwnerReadFavoriteDogBreed as json.
func (s PetOwnerReadFavoriteDogBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PetOwnerReadFavoriteDogBreed from json.
func (s *PetOwnerReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetOwnerReadFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetOwnerReadFavoriteDogBreed(v) {
	case PetOwnerReadFavoriteDogBreedKuro:
		*s = PetOwnerReadFavoriteDogBreedKuro
	default:
		*s = PetOwnerReadFavoriteDogBreed(v)
	}

	return nil
}

// Encode encodes PetOwnerReadFavoriteFishBreed as json.
func (s PetOwnerReadFavoriteFishBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PetOwnerReadFavoriteFishBreed from json.
func (s *PetOwnerReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetOwnerReadFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetOwnerReadFavoriteFishBreed(v) {
	case PetOwnerReadFavoriteFishBreedGold:
		*s = PetOwnerReadFavoriteFishBreedGold
	case PetOwnerReadFavoriteFishBreedKoi:
		*s = PetOwnerReadFavoriteFishBreedKoi
	case PetOwnerReadFavoriteFishBreedShark:
		*s = PetOwnerReadFavoriteFishBreedShark
	default:
		*s = PetOwnerReadFavoriteFishBreed(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetRead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetRead = [4]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
}

// Decode decodes PetRead from json.
func (s *PetRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetRead) {
					name = jsonFieldsNameOfPetRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PetUpdate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPetUpdate = [4]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
}

// Decode decodes PetUpdate from json.
func (s *PetUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetUpdate) {
					name = jsonFieldsNameOfPetUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s R400) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		e.Int(s.Code)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		if len(s.Errors) != 0 {
			e.Comma()
		}

		if len(s.Errors) != 0 {
			e.RawStr("\"errors\"" + ":")
			e.Raw(s.Errors)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfR400 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R400 from json.
func (s *R400) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R400 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R400")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR400) {
					name = jsonFieldsNameOfR400[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s R404) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		e.Int(s.Code)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		if len(s.Errors) != 0 {
			e.Comma()
		}

		if len(s.Errors) != 0 {
			e.RawStr("\"errors\"" + ":")
			e.Raw(s.Errors)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfR404 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R404 from json.
func (s *R404) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R404 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R404")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR404) {
					name = jsonFieldsNameOfR404[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s R409) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		e.Int(s.Code)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		if len(s.Errors) != 0 {
			e.Comma()
		}

		if len(s.Errors) != 0 {
			e.RawStr("\"errors\"" + ":")
			e.Raw(s.Errors)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfR409 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R409 from json.
func (s *R409) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R409 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R409")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR409) {
					name = jsonFieldsNameOfR409[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s R500) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		e.Int(s.Code)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		if len(s.Errors) != 0 {
			e.Comma()
		}

		if len(s.Errors) != 0 {
			e.RawStr("\"errors\"" + ":")
			e.Raw(s.Errors)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfR500 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R500 from json.
func (s *R500) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R500 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R500")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR500) {
					name = jsonFieldsNameOfR500[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UpdateCategoryReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Pets != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pets != nil {
			e.RawStr("\"pets\"" + ":")
			e.ArrStart()
			if len(s.Pets) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Pets[0]
					e.Int(elem)
				}
				for _, elem := range s.Pets[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUpdateCategoryReq = [2]string{
	0: "name",
	1: "pets",
}

// Decode decodes UpdateCategoryReq from json.
func (s *UpdateCategoryReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCategoryReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "pets":
			if err := func() error {
				s.Pets = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Pets = append(s.Pets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCategoryReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UpdatePetReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Weight.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Categories != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Categories != nil {
			e.RawStr("\"categories\"" + ":")
			e.ArrStart()
			if len(s.Categories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Categories[0]
					e.Int(elem)
				}
				for _, elem := range s.Categories[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Owner.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Friends != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Friends != nil {
			e.RawStr("\"friends\"" + ":")
			e.ArrStart()
			if len(s.Friends) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Friends[0]
					e.Int(elem)
				}
				for _, elem := range s.Friends[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUpdatePetReq = [6]string{
	0: "name",
	1: "weight",
	2: "birthday",
	3: "categories",
	4: "owner",
	5: "friends",
}

// Decode decodes UpdatePetReq from json.
func (s *UpdatePetReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePetReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "categories":
			if err := func() error {
				s.Categories = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "friends":
			if err := func() error {
				s.Friends = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Friends = append(s.Friends, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friends\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePetReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UpdateUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Age.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Age.Set {
			e.RawStr("\"age\"" + ":")
			s.Age.Encode(e)
		}
	}
	{
		if s.FavoriteCatBreed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FavoriteCatBreed.Set {
			e.RawStr("\"favorite_cat_breed\"" + ":")
			s.FavoriteCatBreed.Encode(e)
		}
	}
	{
		if s.FavoriteDogBreed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FavoriteDogBreed.Set {
			e.RawStr("\"favorite_dog_breed\"" + ":")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FavoriteFishBreed.Set {
			e.RawStr("\"favorite_fish_breed\"" + ":")
			s.FavoriteFishBreed.Encode(e)
		}
	}
	{
		if s.Pets != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pets != nil {
			e.RawStr("\"pets\"" + ":")
			e.ArrStart()
			if len(s.Pets) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Pets[0]
					e.Int(elem)
				}
				for _, elem := range s.Pets[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.BestFriend.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BestFriend.Set {
			e.RawStr("\"best_friend\"" + ":")
			s.BestFriend.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUpdateUserReq = [7]string{
	0: "name",
	1: "age",
	2: "favorite_cat_breed",
	3: "favorite_dog_breed",
	4: "favorite_fish_breed",
	5: "pets",
	6: "best_friend",
}

// Decode decodes UpdateUserReq from json.
func (s *UpdateUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			if err := func() error {
				s.Age.Reset()
				if err := s.Age.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "favorite_cat_breed":
			if err := func() error {
				s.FavoriteCatBreed.Reset()
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		case "pets":
			if err := func() error {
				s.Pets = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Pets = append(s.Pets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pets\"")
			}
		case "best_friend":
			if err := func() error {
				s.BestFriend.Reset()
				if err := s.BestFriend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"best_friend\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUserReq")
	}

	return nil
}

// Encode encodes UpdateUserReqFavoriteCatBreed as json.
func (s UpdateUserReqFavoriteCatBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UpdateUserReqFavoriteCatBreed from json.
func (s *UpdateUserReqFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserReqFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserReqFavoriteCatBreed(v) {
	case UpdateUserReqFavoriteCatBreedSiamese:
		*s = UpdateUserReqFavoriteCatBreedSiamese
	case UpdateUserReqFavoriteCatBreedBengal:
		*s = UpdateUserReqFavoriteCatBreedBengal
	case UpdateUserReqFavoriteCatBreedLion:
		*s = UpdateUserReqFavoriteCatBreedLion
	case UpdateUserReqFavoriteCatBreedTiger:
		*s = UpdateUserReqFavoriteCatBreedTiger
	case UpdateUserReqFavoriteCatBreedLeopard:
		*s = UpdateUserReqFavoriteCatBreedLeopard
	case UpdateUserReqFavoriteCatBreedOther:
		*s = UpdateUserReqFavoriteCatBreedOther
	default:
		*s = UpdateUserReqFavoriteCatBreed(v)
	}

	return nil
}

// Encode encodes UpdateUserReqFavoriteDogBreed as json.
func (s UpdateUserReqFavoriteDogBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UpdateUserReqFavoriteDogBreed from json.
func (s *UpdateUserReqFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserReqFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserReqFavoriteDogBreed(v) {
	case UpdateUserReqFavoriteDogBreedKuro:
		*s = UpdateUserReqFavoriteDogBreedKuro
	default:
		*s = UpdateUserReqFavoriteDogBreed(v)
	}

	return nil
}

// Encode encodes UpdateUserReqFavoriteFishBreed as json.
func (s UpdateUserReqFavoriteFishBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UpdateUserReqFavoriteFishBreed from json.
func (s *UpdateUserReqFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserReqFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserReqFavoriteFishBreed(v) {
	case UpdateUserReqFavoriteFishBreedGold:
		*s = UpdateUserReqFavoriteFishBreedGold
	case UpdateUserReqFavoriteFishBreedKoi:
		*s = UpdateUserReqFavoriteFishBreedKoi
	case UpdateUserReqFavoriteFishBreedShark:
		*s = UpdateUserReqFavoriteFishBreedShark
	default:
		*s = UpdateUserReqFavoriteFishBreed(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserBestFriendRead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"age\"" + ":")
		e.Int(s.Age)
	}
	{
		e.Comma()

		e.RawStr("\"favorite_cat_breed\"" + ":")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.Comma()
		}
		if s.FavoriteDogBreed.Set {
			e.RawStr("\"favorite_dog_breed\"" + ":")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.Comma()
		}
		if s.FavoriteFishBreed.Set {
			e.RawStr("\"favorite_fish_breed\"" + ":")
			s.FavoriteFishBreed.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserBestFriendRead = [6]string{
	0: "id",
	1: "name",
	2: "age",
	3: "favorite_cat_breed",
	4: "favorite_dog_breed",
	5: "favorite_fish_breed",
}

// Decode decodes UserBestFriendRead from json.
func (s *UserBestFriendRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBestFriendRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Age = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserBestFriendRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserBestFriendRead) {
					name = jsonFieldsNameOfUserBestFriendRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes UserBestFriendReadFavoriteCatBreed as json.
func (s UserBestFriendReadFavoriteCatBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserBestFriendReadFavoriteCatBreed from json.
func (s *UserBestFriendReadFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBestFriendReadFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserBestFriendReadFavoriteCatBreed(v) {
	case UserBestFriendReadFavoriteCatBreedSiamese:
		*s = UserBestFriendReadFavoriteCatBreedSiamese
	case UserBestFriendReadFavoriteCatBreedBengal:
		*s = UserBestFriendReadFavoriteCatBreedBengal
	case UserBestFriendReadFavoriteCatBreedLion:
		*s = UserBestFriendReadFavoriteCatBreedLion
	case UserBestFriendReadFavoriteCatBreedTiger:
		*s = UserBestFriendReadFavoriteCatBreedTiger
	case UserBestFriendReadFavoriteCatBreedLeopard:
		*s = UserBestFriendReadFavoriteCatBreedLeopard
	case UserBestFriendReadFavoriteCatBreedOther:
		*s = UserBestFriendReadFavoriteCatBreedOther
	default:
		*s = UserBestFriendReadFavoriteCatBreed(v)
	}

	return nil
}

// Encode encodes UserBestFriendReadFavoriteDogBreed as json.
func (s UserBestFriendReadFavoriteDogBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserBestFriendReadFavoriteDogBreed from json.
func (s *UserBestFriendReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBestFriendReadFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserBestFriendReadFavoriteDogBreed(v) {
	case UserBestFriendReadFavoriteDogBreedKuro:
		*s = UserBestFriendReadFavoriteDogBreedKuro
	default:
		*s = UserBestFriendReadFavoriteDogBreed(v)
	}

	return nil
}

// Encode encodes UserBestFriendReadFavoriteFishBreed as json.
func (s UserBestFriendReadFavoriteFishBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserBestFriendReadFavoriteFishBreed from json.
func (s *UserBestFriendReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBestFriendReadFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserBestFriendReadFavoriteFishBreed(v) {
	case UserBestFriendReadFavoriteFishBreedGold:
		*s = UserBestFriendReadFavoriteFishBreedGold
	case UserBestFriendReadFavoriteFishBreedKoi:
		*s = UserBestFriendReadFavoriteFishBreedKoi
	case UserBestFriendReadFavoriteFishBreedShark:
		*s = UserBestFriendReadFavoriteFishBreedShark
	default:
		*s = UserBestFriendReadFavoriteFishBreed(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserCreate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"age\"" + ":")
		e.Int(s.Age)
	}
	{
		e.Comma()

		e.RawStr("\"favorite_cat_breed\"" + ":")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.Comma()
		}
		if s.FavoriteDogBreed.Set {
			e.RawStr("\"favorite_dog_breed\"" + ":")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.Comma()
		}
		if s.FavoriteFishBreed.Set {
			e.RawStr("\"favorite_fish_breed\"" + ":")
			s.FavoriteFishBreed.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserCreate = [6]string{
	0: "id",
	1: "name",
	2: "age",
	3: "favorite_cat_breed",
	4: "favorite_dog_breed",
	5: "favorite_fish_breed",
}

// Decode decodes UserCreate from json.
func (s *UserCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Age = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserCreate) {
					name = jsonFieldsNameOfUserCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes UserCreateFavoriteCatBreed as json.
func (s UserCreateFavoriteCatBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserCreateFavoriteCatBreed from json.
func (s *UserCreateFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreateFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserCreateFavoriteCatBreed(v) {
	case UserCreateFavoriteCatBreedSiamese:
		*s = UserCreateFavoriteCatBreedSiamese
	case UserCreateFavoriteCatBreedBengal:
		*s = UserCreateFavoriteCatBreedBengal
	case UserCreateFavoriteCatBreedLion:
		*s = UserCreateFavoriteCatBreedLion
	case UserCreateFavoriteCatBreedTiger:
		*s = UserCreateFavoriteCatBreedTiger
	case UserCreateFavoriteCatBreedLeopard:
		*s = UserCreateFavoriteCatBreedLeopard
	case UserCreateFavoriteCatBreedOther:
		*s = UserCreateFavoriteCatBreedOther
	default:
		*s = UserCreateFavoriteCatBreed(v)
	}

	return nil
}

// Encode encodes UserCreateFavoriteDogBreed as json.
func (s UserCreateFavoriteDogBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserCreateFavoriteDogBreed from json.
func (s *UserCreateFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreateFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserCreateFavoriteDogBreed(v) {
	case UserCreateFavoriteDogBreedKuro:
		*s = UserCreateFavoriteDogBreedKuro
	default:
		*s = UserCreateFavoriteDogBreed(v)
	}

	return nil
}

// Encode encodes UserCreateFavoriteFishBreed as json.
func (s UserCreateFavoriteFishBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserCreateFavoriteFishBreed from json.
func (s *UserCreateFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreateFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserCreateFavoriteFishBreed(v) {
	case UserCreateFavoriteFishBreedGold:
		*s = UserCreateFavoriteFishBreedGold
	case UserCreateFavoriteFishBreedKoi:
		*s = UserCreateFavoriteFishBreedKoi
	case UserCreateFavoriteFishBreedShark:
		*s = UserCreateFavoriteFishBreedShark
	default:
		*s = UserCreateFavoriteFishBreed(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"age\"" + ":")
		e.Int(s.Age)
	}
	{
		e.Comma()

		e.RawStr("\"favorite_cat_breed\"" + ":")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.Comma()
		}
		if s.FavoriteDogBreed.Set {
			e.RawStr("\"favorite_dog_breed\"" + ":")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.Comma()
		}
		if s.FavoriteFishBreed.Set {
			e.RawStr("\"favorite_fish_breed\"" + ":")
			s.FavoriteFishBreed.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserList = [6]string{
	0: "id",
	1: "name",
	2: "age",
	3: "favorite_cat_breed",
	4: "favorite_dog_breed",
	5: "favorite_fish_breed",
}

// Decode decodes UserList from json.
func (s *UserList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Age = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserList) {
					name = jsonFieldsNameOfUserList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes UserListFavoriteCatBreed as json.
func (s UserListFavoriteCatBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserListFavoriteCatBreed from json.
func (s *UserListFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserListFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserListFavoriteCatBreed(v) {
	case UserListFavoriteCatBreedSiamese:
		*s = UserListFavoriteCatBreedSiamese
	case UserListFavoriteCatBreedBengal:
		*s = UserListFavoriteCatBreedBengal
	case UserListFavoriteCatBreedLion:
		*s = UserListFavoriteCatBreedLion
	case UserListFavoriteCatBreedTiger:
		*s = UserListFavoriteCatBreedTiger
	case UserListFavoriteCatBreedLeopard:
		*s = UserListFavoriteCatBreedLeopard
	case UserListFavoriteCatBreedOther:
		*s = UserListFavoriteCatBreedOther
	default:
		*s = UserListFavoriteCatBreed(v)
	}

	return nil
}

// Encode encodes UserListFavoriteDogBreed as json.
func (s UserListFavoriteDogBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserListFavoriteDogBreed from json.
func (s *UserListFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserListFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserListFavoriteDogBreed(v) {
	case UserListFavoriteDogBreedKuro:
		*s = UserListFavoriteDogBreedKuro
	default:
		*s = UserListFavoriteDogBreed(v)
	}

	return nil
}

// Encode encodes UserListFavoriteFishBreed as json.
func (s UserListFavoriteFishBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserListFavoriteFishBreed from json.
func (s *UserListFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserListFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserListFavoriteFishBreed(v) {
	case UserListFavoriteFishBreedGold:
		*s = UserListFavoriteFishBreedGold
	case UserListFavoriteFishBreedKoi:
		*s = UserListFavoriteFishBreedKoi
	case UserListFavoriteFishBreedShark:
		*s = UserListFavoriteFishBreedShark
	default:
		*s = UserListFavoriteFishBreed(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserPetsList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.Comma()
		}
		if s.Weight.Set {
			e.RawStr("\"weight\"" + ":")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.Comma()
		}
		if s.Birthday.Set {
			e.RawStr("\"birthday\"" + ":")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserPetsList = [4]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
}

// Decode decodes UserPetsList from json.
func (s *UserPetsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserPetsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserPetsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserPetsList) {
					name = jsonFieldsNameOfUserPetsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserRead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"age\"" + ":")
		e.Int(s.Age)
	}
	{
		e.Comma()

		e.RawStr("\"favorite_cat_breed\"" + ":")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.Comma()
		}
		if s.FavoriteDogBreed.Set {
			e.RawStr("\"favorite_dog_breed\"" + ":")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.Comma()
		}
		if s.FavoriteFishBreed.Set {
			e.RawStr("\"favorite_fish_breed\"" + ":")
			s.FavoriteFishBreed.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserRead = [6]string{
	0: "id",
	1: "name",
	2: "age",
	3: "favorite_cat_breed",
	4: "favorite_dog_breed",
	5: "favorite_fish_breed",
}

// Decode decodes UserRead from json.
func (s *UserRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Age = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserRead) {
					name = jsonFieldsNameOfUserRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes UserReadFavoriteCatBreed as json.
func (s UserReadFavoriteCatBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserReadFavoriteCatBreed from json.
func (s *UserReadFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserReadFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserReadFavoriteCatBreed(v) {
	case UserReadFavoriteCatBreedSiamese:
		*s = UserReadFavoriteCatBreedSiamese
	case UserReadFavoriteCatBreedBengal:
		*s = UserReadFavoriteCatBreedBengal
	case UserReadFavoriteCatBreedLion:
		*s = UserReadFavoriteCatBreedLion
	case UserReadFavoriteCatBreedTiger:
		*s = UserReadFavoriteCatBreedTiger
	case UserReadFavoriteCatBreedLeopard:
		*s = UserReadFavoriteCatBreedLeopard
	case UserReadFavoriteCatBreedOther:
		*s = UserReadFavoriteCatBreedOther
	default:
		*s = UserReadFavoriteCatBreed(v)
	}

	return nil
}

// Encode encodes UserReadFavoriteDogBreed as json.
func (s UserReadFavoriteDogBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserReadFavoriteDogBreed from json.
func (s *UserReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserReadFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserReadFavoriteDogBreed(v) {
	case UserReadFavoriteDogBreedKuro:
		*s = UserReadFavoriteDogBreedKuro
	default:
		*s = UserReadFavoriteDogBreed(v)
	}

	return nil
}

// Encode encodes UserReadFavoriteFishBreed as json.
func (s UserReadFavoriteFishBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserReadFavoriteFishBreed from json.
func (s *UserReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserReadFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserReadFavoriteFishBreed(v) {
	case UserReadFavoriteFishBreedGold:
		*s = UserReadFavoriteFishBreedGold
	case UserReadFavoriteFishBreedKoi:
		*s = UserReadFavoriteFishBreedKoi
	case UserReadFavoriteFishBreedShark:
		*s = UserReadFavoriteFishBreedShark
	default:
		*s = UserReadFavoriteFishBreed(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserUpdate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"age\"" + ":")
		e.Int(s.Age)
	}
	{
		e.Comma()

		e.RawStr("\"favorite_cat_breed\"" + ":")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.Comma()
		}
		if s.FavoriteDogBreed.Set {
			e.RawStr("\"favorite_dog_breed\"" + ":")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.Comma()
		}
		if s.FavoriteFishBreed.Set {
			e.RawStr("\"favorite_fish_breed\"" + ":")
			s.FavoriteFishBreed.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserUpdate = [6]string{
	0: "id",
	1: "name",
	2: "age",
	3: "favorite_cat_breed",
	4: "favorite_dog_breed",
	5: "favorite_fish_breed",
}

// Decode decodes UserUpdate from json.
func (s *UserUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Age = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserUpdate) {
					name = jsonFieldsNameOfUserUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes UserUpdateFavoriteCatBreed as json.
func (s UserUpdateFavoriteCatBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserUpdateFavoriteCatBreed from json.
func (s *UserUpdateFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUpdateFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserUpdateFavoriteCatBreed(v) {
	case UserUpdateFavoriteCatBreedSiamese:
		*s = UserUpdateFavoriteCatBreedSiamese
	case UserUpdateFavoriteCatBreedBengal:
		*s = UserUpdateFavoriteCatBreedBengal
	case UserUpdateFavoriteCatBreedLion:
		*s = UserUpdateFavoriteCatBreedLion
	case UserUpdateFavoriteCatBreedTiger:
		*s = UserUpdateFavoriteCatBreedTiger
	case UserUpdateFavoriteCatBreedLeopard:
		*s = UserUpdateFavoriteCatBreedLeopard
	case UserUpdateFavoriteCatBreedOther:
		*s = UserUpdateFavoriteCatBreedOther
	default:
		*s = UserUpdateFavoriteCatBreed(v)
	}

	return nil
}

// Encode encodes UserUpdateFavoriteDogBreed as json.
func (s UserUpdateFavoriteDogBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserUpdateFavoriteDogBreed from json.
func (s *UserUpdateFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUpdateFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserUpdateFavoriteDogBreed(v) {
	case UserUpdateFavoriteDogBreedKuro:
		*s = UserUpdateFavoriteDogBreedKuro
	default:
		*s = UserUpdateFavoriteDogBreed(v)
	}

	return nil
}

// Encode encodes UserUpdateFavoriteFishBreed as json.
func (s UserUpdateFavoriteFishBreed) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UserUpdateFavoriteFishBreed from json.
func (s *UserUpdateFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUpdateFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserUpdateFavoriteFishBreed(v) {
	case UserUpdateFavoriteFishBreedGold:
		*s = UserUpdateFavoriteFishBreedGold
	case UserUpdateFavoriteFishBreedKoi:
		*s = UserUpdateFavoriteFishBreedKoi
	case UserUpdateFavoriteFishBreedShark:
		*s = UserUpdateFavoriteFishBreedShark
	default:
		*s = UserUpdateFavoriteFishBreed(v)
	}

	return nil
}
