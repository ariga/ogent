// Code generated by ogen, DO NOT EDIT.

package ogent

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AllTypesCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AllTypesCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{

		e.FieldStart("int")
		e.Int(s.Int)
	}
	{

		e.FieldStart("int8")
		e.Int32(s.Int8)
	}
	{

		e.FieldStart("int16")
		e.Int32(s.Int16)
	}
	{

		e.FieldStart("int32")
		e.Int32(s.Int32)
	}
	{

		e.FieldStart("int64")
		e.Int64(s.Int64)
	}
	{

		e.FieldStart("uint")
		e.Int64(s.Uint)
	}
	{

		e.FieldStart("uint8")
		e.Int32(s.Uint8)
	}
	{

		e.FieldStart("uint16")
		e.Int32(s.Uint16)
	}
	{

		e.FieldStart("uint32")
		e.Int64(s.Uint32)
	}
	{

		e.FieldStart("uint64")
		e.Int64(s.Uint64)
	}
	{

		e.FieldStart("float32")
		e.Float32(s.Float32)
	}
	{

		e.FieldStart("float64")
		e.Float64(s.Float64)
	}
	{

		e.FieldStart("string_type")
		e.Str(s.StringType)
	}
	{

		e.FieldStart("bool")
		e.Bool(s.Bool)
	}
	{

		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{

		e.FieldStart("time")
		json.EncodeDateTime(e, s.Time)
	}
	{

		e.FieldStart("text")
		e.Str(s.Text)
	}
	{

		e.FieldStart("state")
		s.State.Encode(e)
	}
	{

		e.FieldStart("bytes")
		e.Base64(s.Bytes)
	}
	{
		if s.Nilable.Set {
			e.FieldStart("nilable")
			s.Nilable.Encode(e)
		}
	}
}

var jsonFieldsNameOfAllTypesCreate = [21]string{
	0:  "id",
	1:  "int",
	2:  "int8",
	3:  "int16",
	4:  "int32",
	5:  "int64",
	6:  "uint",
	7:  "uint8",
	8:  "uint16",
	9:  "uint32",
	10: "uint64",
	11: "float32",
	12: "float64",
	13: "string_type",
	14: "bool",
	15: "uuid",
	16: "time",
	17: "text",
	18: "state",
	19: "bytes",
	20: "nilable",
}

// Decode decodes AllTypesCreate from json.
func (s *AllTypesCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesCreate to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "int":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Int = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int\"")
			}
		case "int8":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Int8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int8\"")
			}
		case "int16":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Int16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int16\"")
			}
		case "int32":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Int32 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int32\"")
			}
		case "int64":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.Int64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int64\"")
			}
		case "uint":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int64()
				s.Uint = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint\"")
			}
		case "uint8":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Uint8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint8\"")
			}
		case "uint16":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Uint16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint16\"")
			}
		case "uint32":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Uint32 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint32\"")
			}
		case "uint64":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Uint64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint64\"")
			}
		case "float32":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Float32()
				s.Float32 = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float32\"")
			}
		case "float64":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Float64 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float64\"")
			}
		case "string_type":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StringType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"string_type\"")
			}
		case "bool":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Bool = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bool\"")
			}
		case "uuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "time":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "text":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "state":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "bytes":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Base64()
				s.Bytes = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bytes\"")
			}
		case "nilable":
			if err := func() error {
				s.Nilable.Reset()
				if err := s.Nilable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nilable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AllTypesCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAllTypesCreate) {
					name = jsonFieldsNameOfAllTypesCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AllTypesCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AllTypesCreateState as json.
func (s AllTypesCreateState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AllTypesCreateState from json.
func (s *AllTypesCreateState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesCreateState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AllTypesCreateState(v) {
	case AllTypesCreateStateOn:
		*s = AllTypesCreateStateOn
	case AllTypesCreateStateOff:
		*s = AllTypesCreateStateOff
	default:
		*s = AllTypesCreateState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AllTypesCreateState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesCreateState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AllTypesList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AllTypesList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{

		e.FieldStart("int")
		e.Int(s.Int)
	}
	{

		e.FieldStart("int8")
		e.Int32(s.Int8)
	}
	{

		e.FieldStart("int16")
		e.Int32(s.Int16)
	}
	{

		e.FieldStart("int32")
		e.Int32(s.Int32)
	}
	{

		e.FieldStart("int64")
		e.Int64(s.Int64)
	}
	{

		e.FieldStart("uint")
		e.Int64(s.Uint)
	}
	{

		e.FieldStart("uint8")
		e.Int32(s.Uint8)
	}
	{

		e.FieldStart("uint16")
		e.Int32(s.Uint16)
	}
	{

		e.FieldStart("uint32")
		e.Int64(s.Uint32)
	}
	{

		e.FieldStart("uint64")
		e.Int64(s.Uint64)
	}
	{

		e.FieldStart("float32")
		e.Float32(s.Float32)
	}
	{

		e.FieldStart("float64")
		e.Float64(s.Float64)
	}
	{

		e.FieldStart("string_type")
		e.Str(s.StringType)
	}
	{

		e.FieldStart("bool")
		e.Bool(s.Bool)
	}
	{

		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{

		e.FieldStart("time")
		json.EncodeDateTime(e, s.Time)
	}
	{

		e.FieldStart("text")
		e.Str(s.Text)
	}
	{

		e.FieldStart("state")
		s.State.Encode(e)
	}
	{

		e.FieldStart("bytes")
		e.Base64(s.Bytes)
	}
	{
		if s.Nilable.Set {
			e.FieldStart("nilable")
			s.Nilable.Encode(e)
		}
	}
}

var jsonFieldsNameOfAllTypesList = [21]string{
	0:  "id",
	1:  "int",
	2:  "int8",
	3:  "int16",
	4:  "int32",
	5:  "int64",
	6:  "uint",
	7:  "uint8",
	8:  "uint16",
	9:  "uint32",
	10: "uint64",
	11: "float32",
	12: "float64",
	13: "string_type",
	14: "bool",
	15: "uuid",
	16: "time",
	17: "text",
	18: "state",
	19: "bytes",
	20: "nilable",
}

// Decode decodes AllTypesList from json.
func (s *AllTypesList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesList to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "int":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Int = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int\"")
			}
		case "int8":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Int8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int8\"")
			}
		case "int16":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Int16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int16\"")
			}
		case "int32":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Int32 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int32\"")
			}
		case "int64":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.Int64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int64\"")
			}
		case "uint":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int64()
				s.Uint = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint\"")
			}
		case "uint8":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Uint8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint8\"")
			}
		case "uint16":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Uint16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint16\"")
			}
		case "uint32":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Uint32 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint32\"")
			}
		case "uint64":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Uint64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint64\"")
			}
		case "float32":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Float32()
				s.Float32 = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float32\"")
			}
		case "float64":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Float64 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float64\"")
			}
		case "string_type":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StringType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"string_type\"")
			}
		case "bool":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Bool = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bool\"")
			}
		case "uuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "time":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "text":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "state":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "bytes":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Base64()
				s.Bytes = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bytes\"")
			}
		case "nilable":
			if err := func() error {
				s.Nilable.Reset()
				if err := s.Nilable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nilable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AllTypesList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAllTypesList) {
					name = jsonFieldsNameOfAllTypesList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AllTypesList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AllTypesListState as json.
func (s AllTypesListState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AllTypesListState from json.
func (s *AllTypesListState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesListState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AllTypesListState(v) {
	case AllTypesListStateOn:
		*s = AllTypesListStateOn
	case AllTypesListStateOff:
		*s = AllTypesListStateOff
	default:
		*s = AllTypesListState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AllTypesListState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesListState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AllTypesRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AllTypesRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{

		e.FieldStart("int")
		e.Int(s.Int)
	}
	{

		e.FieldStart("int8")
		e.Int32(s.Int8)
	}
	{

		e.FieldStart("int16")
		e.Int32(s.Int16)
	}
	{

		e.FieldStart("int32")
		e.Int32(s.Int32)
	}
	{

		e.FieldStart("int64")
		e.Int64(s.Int64)
	}
	{

		e.FieldStart("uint")
		e.Int64(s.Uint)
	}
	{

		e.FieldStart("uint8")
		e.Int32(s.Uint8)
	}
	{

		e.FieldStart("uint16")
		e.Int32(s.Uint16)
	}
	{

		e.FieldStart("uint32")
		e.Int64(s.Uint32)
	}
	{

		e.FieldStart("uint64")
		e.Int64(s.Uint64)
	}
	{

		e.FieldStart("float32")
		e.Float32(s.Float32)
	}
	{

		e.FieldStart("float64")
		e.Float64(s.Float64)
	}
	{

		e.FieldStart("string_type")
		e.Str(s.StringType)
	}
	{

		e.FieldStart("bool")
		e.Bool(s.Bool)
	}
	{

		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{

		e.FieldStart("time")
		json.EncodeDateTime(e, s.Time)
	}
	{

		e.FieldStart("text")
		e.Str(s.Text)
	}
	{

		e.FieldStart("state")
		s.State.Encode(e)
	}
	{

		e.FieldStart("bytes")
		e.Base64(s.Bytes)
	}
	{
		if s.Nilable.Set {
			e.FieldStart("nilable")
			s.Nilable.Encode(e)
		}
	}
}

var jsonFieldsNameOfAllTypesRead = [21]string{
	0:  "id",
	1:  "int",
	2:  "int8",
	3:  "int16",
	4:  "int32",
	5:  "int64",
	6:  "uint",
	7:  "uint8",
	8:  "uint16",
	9:  "uint32",
	10: "uint64",
	11: "float32",
	12: "float64",
	13: "string_type",
	14: "bool",
	15: "uuid",
	16: "time",
	17: "text",
	18: "state",
	19: "bytes",
	20: "nilable",
}

// Decode decodes AllTypesRead from json.
func (s *AllTypesRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesRead to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "int":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Int = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int\"")
			}
		case "int8":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Int8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int8\"")
			}
		case "int16":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Int16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int16\"")
			}
		case "int32":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Int32 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int32\"")
			}
		case "int64":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.Int64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int64\"")
			}
		case "uint":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int64()
				s.Uint = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint\"")
			}
		case "uint8":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Uint8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint8\"")
			}
		case "uint16":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Uint16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint16\"")
			}
		case "uint32":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Uint32 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint32\"")
			}
		case "uint64":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Uint64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint64\"")
			}
		case "float32":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Float32()
				s.Float32 = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float32\"")
			}
		case "float64":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Float64 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float64\"")
			}
		case "string_type":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StringType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"string_type\"")
			}
		case "bool":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Bool = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bool\"")
			}
		case "uuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "time":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "text":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "state":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "bytes":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Base64()
				s.Bytes = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bytes\"")
			}
		case "nilable":
			if err := func() error {
				s.Nilable.Reset()
				if err := s.Nilable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nilable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AllTypesRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAllTypesRead) {
					name = jsonFieldsNameOfAllTypesRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AllTypesRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AllTypesReadState as json.
func (s AllTypesReadState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AllTypesReadState from json.
func (s *AllTypesReadState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesReadState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AllTypesReadState(v) {
	case AllTypesReadStateOn:
		*s = AllTypesReadStateOn
	case AllTypesReadStateOff:
		*s = AllTypesReadStateOff
	default:
		*s = AllTypesReadState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AllTypesReadState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesReadState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AllTypesUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AllTypesUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{

		e.FieldStart("int")
		e.Int(s.Int)
	}
	{

		e.FieldStart("int8")
		e.Int32(s.Int8)
	}
	{

		e.FieldStart("int16")
		e.Int32(s.Int16)
	}
	{

		e.FieldStart("int32")
		e.Int32(s.Int32)
	}
	{

		e.FieldStart("int64")
		e.Int64(s.Int64)
	}
	{

		e.FieldStart("uint")
		e.Int64(s.Uint)
	}
	{

		e.FieldStart("uint8")
		e.Int32(s.Uint8)
	}
	{

		e.FieldStart("uint16")
		e.Int32(s.Uint16)
	}
	{

		e.FieldStart("uint32")
		e.Int64(s.Uint32)
	}
	{

		e.FieldStart("uint64")
		e.Int64(s.Uint64)
	}
	{

		e.FieldStart("float32")
		e.Float32(s.Float32)
	}
	{

		e.FieldStart("float64")
		e.Float64(s.Float64)
	}
	{

		e.FieldStart("string_type")
		e.Str(s.StringType)
	}
	{

		e.FieldStart("bool")
		e.Bool(s.Bool)
	}
	{

		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{

		e.FieldStart("time")
		json.EncodeDateTime(e, s.Time)
	}
	{

		e.FieldStart("text")
		e.Str(s.Text)
	}
	{

		e.FieldStart("state")
		s.State.Encode(e)
	}
	{

		e.FieldStart("bytes")
		e.Base64(s.Bytes)
	}
	{
		if s.Nilable.Set {
			e.FieldStart("nilable")
			s.Nilable.Encode(e)
		}
	}
}

var jsonFieldsNameOfAllTypesUpdate = [21]string{
	0:  "id",
	1:  "int",
	2:  "int8",
	3:  "int16",
	4:  "int32",
	5:  "int64",
	6:  "uint",
	7:  "uint8",
	8:  "uint16",
	9:  "uint32",
	10: "uint64",
	11: "float32",
	12: "float64",
	13: "string_type",
	14: "bool",
	15: "uuid",
	16: "time",
	17: "text",
	18: "state",
	19: "bytes",
	20: "nilable",
}

// Decode decodes AllTypesUpdate from json.
func (s *AllTypesUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesUpdate to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "int":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Int = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int\"")
			}
		case "int8":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Int8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int8\"")
			}
		case "int16":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Int16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int16\"")
			}
		case "int32":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Int32 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int32\"")
			}
		case "int64":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.Int64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int64\"")
			}
		case "uint":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int64()
				s.Uint = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint\"")
			}
		case "uint8":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Uint8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint8\"")
			}
		case "uint16":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Uint16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint16\"")
			}
		case "uint32":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Uint32 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint32\"")
			}
		case "uint64":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Uint64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint64\"")
			}
		case "float32":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Float32()
				s.Float32 = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float32\"")
			}
		case "float64":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Float64 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float64\"")
			}
		case "string_type":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StringType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"string_type\"")
			}
		case "bool":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Bool = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bool\"")
			}
		case "uuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "time":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "text":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "state":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "bytes":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Base64()
				s.Bytes = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bytes\"")
			}
		case "nilable":
			if err := func() error {
				s.Nilable.Reset()
				if err := s.Nilable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nilable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AllTypesUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAllTypesUpdate) {
					name = jsonFieldsNameOfAllTypesUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AllTypesUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AllTypesUpdateState as json.
func (s AllTypesUpdateState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AllTypesUpdateState from json.
func (s *AllTypesUpdateState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesUpdateState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AllTypesUpdateState(v) {
	case AllTypesUpdateStateOn:
		*s = AllTypesUpdateStateOn
	case AllTypesUpdateStateOff:
		*s = AllTypesUpdateStateOff
	default:
		*s = AllTypesUpdateState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AllTypesUpdateState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesUpdateState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoryCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoryCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Readonly.Set {
			e.FieldStart("readonly")
			s.Readonly.Encode(e)
		}
	}
}

var jsonFieldsNameOfCategoryCreate = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes CategoryCreate from json.
func (s *CategoryCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			if err := func() error {
				s.Readonly.Reset()
				if err := s.Readonly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryCreate) {
					name = jsonFieldsNameOfCategoryCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoryCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoryCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoryList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoryList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Readonly.Set {
			e.FieldStart("readonly")
			s.Readonly.Encode(e)
		}
	}
}

var jsonFieldsNameOfCategoryList = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes CategoryList from json.
func (s *CategoryList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			if err := func() error {
				s.Readonly.Reset()
				if err := s.Readonly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryList) {
					name = jsonFieldsNameOfCategoryList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoryList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoryList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoryPetsList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoryPetsList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
}

var jsonFieldsNameOfCategoryPetsList = [6]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "tag_id",
	5: "height",
}

// Decode decodes CategoryPetsList from json.
func (s *CategoryPetsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryPetsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryPetsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryPetsList) {
					name = jsonFieldsNameOfCategoryPetsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoryPetsList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoryPetsList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoryRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoryRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Readonly.Set {
			e.FieldStart("readonly")
			s.Readonly.Encode(e)
		}
	}
}

var jsonFieldsNameOfCategoryRead = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes CategoryRead from json.
func (s *CategoryRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			if err := func() error {
				s.Readonly.Reset()
				if err := s.Readonly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryRead) {
					name = jsonFieldsNameOfCategoryRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoryRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoryRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoryUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoryUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Readonly.Set {
			e.FieldStart("readonly")
			s.Readonly.Encode(e)
		}
	}
}

var jsonFieldsNameOfCategoryUpdate = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes CategoryUpdate from json.
func (s *CategoryUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			if err := func() error {
				s.Readonly.Reset()
				if err := s.Readonly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryUpdate) {
					name = jsonFieldsNameOfCategoryUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoryUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoryUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAllTypesReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAllTypesReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("int")
		e.Int(s.Int)
	}
	{

		e.FieldStart("int8")
		e.Int32(s.Int8)
	}
	{

		e.FieldStart("int16")
		e.Int32(s.Int16)
	}
	{

		e.FieldStart("int32")
		e.Int32(s.Int32)
	}
	{

		e.FieldStart("int64")
		e.Int64(s.Int64)
	}
	{

		e.FieldStart("uint")
		e.Int64(s.Uint)
	}
	{

		e.FieldStart("uint8")
		e.Int32(s.Uint8)
	}
	{

		e.FieldStart("uint16")
		e.Int32(s.Uint16)
	}
	{

		e.FieldStart("uint32")
		e.Int64(s.Uint32)
	}
	{

		e.FieldStart("uint64")
		e.Int64(s.Uint64)
	}
	{

		e.FieldStart("float32")
		e.Float32(s.Float32)
	}
	{

		e.FieldStart("float64")
		e.Float64(s.Float64)
	}
	{

		e.FieldStart("string_type")
		e.Str(s.StringType)
	}
	{

		e.FieldStart("bool")
		e.Bool(s.Bool)
	}
	{

		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{

		e.FieldStart("time")
		json.EncodeDateTime(e, s.Time)
	}
	{

		e.FieldStart("text")
		e.Str(s.Text)
	}
	{

		e.FieldStart("state")
		s.State.Encode(e)
	}
	{

		e.FieldStart("bytes")
		e.Base64(s.Bytes)
	}
	{

		e.FieldStart("nilable")
		e.Str(s.Nilable)
	}
}

var jsonFieldsNameOfCreateAllTypesReq = [20]string{
	0:  "int",
	1:  "int8",
	2:  "int16",
	3:  "int32",
	4:  "int64",
	5:  "uint",
	6:  "uint8",
	7:  "uint16",
	8:  "uint32",
	9:  "uint64",
	10: "float32",
	11: "float64",
	12: "string_type",
	13: "bool",
	14: "uuid",
	15: "time",
	16: "text",
	17: "state",
	18: "bytes",
	19: "nilable",
}

// Decode decodes CreateAllTypesReq from json.
func (s *CreateAllTypesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAllTypesReq to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "int":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Int = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int\"")
			}
		case "int8":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Int8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int8\"")
			}
		case "int16":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Int16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int16\"")
			}
		case "int32":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Int32 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int32\"")
			}
		case "int64":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.Int64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int64\"")
			}
		case "uint":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.Uint = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint\"")
			}
		case "uint8":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.Uint8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint8\"")
			}
		case "uint16":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Uint16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint16\"")
			}
		case "uint32":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.Uint32 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint32\"")
			}
		case "uint64":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Uint64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint64\"")
			}
		case "float32":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.Float32 = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float32\"")
			}
		case "float64":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Float64 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float64\"")
			}
		case "string_type":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.StringType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"string_type\"")
			}
		case "bool":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Bool = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bool\"")
			}
		case "uuid":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "time":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "text":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "state":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "bytes":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Base64()
				s.Bytes = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bytes\"")
			}
		case "nilable":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Nilable = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nilable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateAllTypesReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateAllTypesReq) {
					name = jsonFieldsNameOfCreateAllTypesReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAllTypesReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAllTypesReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAllTypesReqState as json.
func (s CreateAllTypesReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateAllTypesReqState from json.
func (s *CreateAllTypesReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAllTypesReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateAllTypesReqState(v) {
	case CreateAllTypesReqStateOn:
		*s = CreateAllTypesReqStateOn
	case CreateAllTypesReqStateOff:
		*s = CreateAllTypesReqStateOff
	default:
		*s = CreateAllTypesReqState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateAllTypesReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAllTypesReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateCategoryReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateCategoryReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Pets != nil {
			e.FieldStart("pets")
			e.ArrStart()
			for _, elem := range s.Pets {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateCategoryReq = [2]string{
	0: "name",
	1: "pets",
}

// Decode decodes CreateCategoryReq from json.
func (s *CreateCategoryReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCategoryReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "pets":
			if err := func() error {
				s.Pets = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Pets = append(s.Pets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateCategoryReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateCategoryReq) {
					name = jsonFieldsNameOfCreateCategoryReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCategoryReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCategoryReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHatReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHatReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Wearer.Set {
			e.FieldStart("wearer")
			s.Wearer.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateHatReq = [3]string{
	0: "name",
	1: "type",
	2: "wearer",
}

// Decode decodes CreateHatReq from json.
func (s *CreateHatReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHatReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "wearer":
			if err := func() error {
				s.Wearer.Reset()
				if err := s.Wearer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wearer\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHatReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHatReq) {
					name = jsonFieldsNameOfCreateHatReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHatReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHatReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHatReqType as json.
func (s CreateHatReqType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateHatReqType from json.
func (s *CreateHatReqType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHatReqType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateHatReqType(v) {
	case CreateHatReqTypeDad:
		*s = CreateHatReqTypeDad
	case CreateHatReqTypeTrucker:
		*s = CreateHatReqTypeTrucker
	case CreateHatReqTypeSnapback:
		*s = CreateHatReqTypeSnapback
	default:
		*s = CreateHatReqType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateHatReqType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHatReqType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreatePetReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreatePetReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Categories != nil {
			e.FieldStart("categories")
			e.ArrStart()
			for _, elem := range s.Categories {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{

		e.FieldStart("owner")
		e.Int(s.Owner)
	}
	{
		if s.Rescuer != nil {
			e.FieldStart("rescuer")
			e.ArrStart()
			for _, elem := range s.Rescuer {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Friends != nil {
			e.FieldStart("friends")
			e.ArrStart()
			for _, elem := range s.Friends {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreatePetReq = [9]string{
	0: "name",
	1: "weight",
	2: "birthday",
	3: "tag_id",
	4: "height",
	5: "categories",
	6: "owner",
	7: "rescuer",
	8: "friends",
}

// Decode decodes CreatePetReq from json.
func (s *CreatePetReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePetReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "categories":
			if err := func() error {
				s.Categories = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Owner = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "rescuer":
			if err := func() error {
				s.Rescuer = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Rescuer = append(s.Rescuer, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rescuer\"")
			}
		case "friends":
			if err := func() error {
				s.Friends = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Friends = append(s.Friends, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friends\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreatePetReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatePetReq) {
					name = jsonFieldsNameOfCreatePetReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatePetReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePetReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{

		e.FieldStart("favorite_color")
		s.FavoriteColor.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
	{
		if s.Pets != nil {
			e.FieldStart("pets")
			e.ArrStart()
			for _, elem := range s.Pets {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AnimalsSaved != nil {
			e.FieldStart("animals_saved")
			e.ArrStart()
			for _, elem := range s.AnimalsSaved {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BestFriend.Set {
			e.FieldStart("best_friend")
			s.BestFriend.Encode(e)
		}
	}
	{
		if s.FavoriteHat.Set {
			e.FieldStart("favorite_hat")
			s.FavoriteHat.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateUserReq = [11]string{
	0:  "name",
	1:  "age",
	2:  "height",
	3:  "favorite_cat_breed",
	4:  "favorite_color",
	5:  "favorite_dog_breed",
	6:  "favorite_fish_breed",
	7:  "pets",
	8:  "animals_saved",
	9:  "best_friend",
	10: "favorite_hat",
}

// Decode decodes CreateUserReq from json.
func (s *CreateUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserReq to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_color":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_color\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		case "pets":
			if err := func() error {
				s.Pets = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Pets = append(s.Pets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pets\"")
			}
		case "animals_saved":
			if err := func() error {
				s.AnimalsSaved = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.AnimalsSaved = append(s.AnimalsSaved, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"animals_saved\"")
			}
		case "best_friend":
			if err := func() error {
				s.BestFriend.Reset()
				if err := s.BestFriend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"best_friend\"")
			}
		case "favorite_hat":
			if err := func() error {
				s.FavoriteHat.Reset()
				if err := s.FavoriteHat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_hat\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserReq) {
					name = jsonFieldsNameOfCreateUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserReqFavoriteCatBreed as json.
func (s CreateUserReqFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateUserReqFavoriteCatBreed from json.
func (s *CreateUserReqFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserReqFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserReqFavoriteCatBreed(v) {
	case CreateUserReqFavoriteCatBreedSiamese:
		*s = CreateUserReqFavoriteCatBreedSiamese
	case CreateUserReqFavoriteCatBreedBengal:
		*s = CreateUserReqFavoriteCatBreedBengal
	case CreateUserReqFavoriteCatBreedLion:
		*s = CreateUserReqFavoriteCatBreedLion
	case CreateUserReqFavoriteCatBreedTiger:
		*s = CreateUserReqFavoriteCatBreedTiger
	case CreateUserReqFavoriteCatBreedLeopard:
		*s = CreateUserReqFavoriteCatBreedLeopard
	case CreateUserReqFavoriteCatBreedOther:
		*s = CreateUserReqFavoriteCatBreedOther
	default:
		*s = CreateUserReqFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserReqFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserReqFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserReqFavoriteColor as json.
func (s CreateUserReqFavoriteColor) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateUserReqFavoriteColor from json.
func (s *CreateUserReqFavoriteColor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserReqFavoriteColor to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserReqFavoriteColor(v) {
	case CreateUserReqFavoriteColorRed:
		*s = CreateUserReqFavoriteColorRed
	case CreateUserReqFavoriteColorGreen:
		*s = CreateUserReqFavoriteColorGreen
	case CreateUserReqFavoriteColorBlue:
		*s = CreateUserReqFavoriteColorBlue
	default:
		*s = CreateUserReqFavoriteColor(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserReqFavoriteColor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserReqFavoriteColor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserReqFavoriteDogBreed as json.
func (s CreateUserReqFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateUserReqFavoriteDogBreed from json.
func (s *CreateUserReqFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserReqFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserReqFavoriteDogBreed(v) {
	case CreateUserReqFavoriteDogBreedKuro:
		*s = CreateUserReqFavoriteDogBreedKuro
	default:
		*s = CreateUserReqFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserReqFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserReqFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserReqFavoriteFishBreed as json.
func (s CreateUserReqFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateUserReqFavoriteFishBreed from json.
func (s *CreateUserReqFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserReqFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserReqFavoriteFishBreed(v) {
	case CreateUserReqFavoriteFishBreedGold:
		*s = CreateUserReqFavoriteFishBreedGold
	case CreateUserReqFavoriteFishBreedKoi:
		*s = CreateUserReqFavoriteFishBreedKoi
	case CreateUserReqFavoriteFishBreedShark:
		*s = CreateUserReqFavoriteFishBreedShark
	default:
		*s = CreateUserReqFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserReqFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserReqFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HatCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HatCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfHatCreate = [3]string{
	0: "id",
	1: "name",
	2: "type",
}

// Decode decodes HatCreate from json.
func (s *HatCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HatCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HatCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHatCreate) {
					name = jsonFieldsNameOfHatCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HatCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HatCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HatCreateType as json.
func (s HatCreateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HatCreateType from json.
func (s *HatCreateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HatCreateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HatCreateType(v) {
	case HatCreateTypeDad:
		*s = HatCreateTypeDad
	case HatCreateTypeTrucker:
		*s = HatCreateTypeTrucker
	case HatCreateTypeSnapback:
		*s = HatCreateTypeSnapback
	default:
		*s = HatCreateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HatCreateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HatCreateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HatList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HatList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfHatList = [3]string{
	0: "id",
	1: "name",
	2: "type",
}

// Decode decodes HatList from json.
func (s *HatList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HatList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HatList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHatList) {
					name = jsonFieldsNameOfHatList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HatList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HatList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HatListType as json.
func (s HatListType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HatListType from json.
func (s *HatListType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HatListType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HatListType(v) {
	case HatListTypeDad:
		*s = HatListTypeDad
	case HatListTypeTrucker:
		*s = HatListTypeTrucker
	case HatListTypeSnapback:
		*s = HatListTypeSnapback
	default:
		*s = HatListType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HatListType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HatListType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HatRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HatRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfHatRead = [3]string{
	0: "id",
	1: "name",
	2: "type",
}

// Decode decodes HatRead from json.
func (s *HatRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HatRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HatRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHatRead) {
					name = jsonFieldsNameOfHatRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HatRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HatRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HatReadType as json.
func (s HatReadType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HatReadType from json.
func (s *HatReadType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HatReadType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HatReadType(v) {
	case HatReadTypeDad:
		*s = HatReadTypeDad
	case HatReadTypeTrucker:
		*s = HatReadTypeTrucker
	case HatReadTypeSnapback:
		*s = HatReadTypeSnapback
	default:
		*s = HatReadType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HatReadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HatReadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HatUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HatUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfHatUpdate = [3]string{
	0: "id",
	1: "name",
	2: "type",
}

// Decode decodes HatUpdate from json.
func (s *HatUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HatUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HatUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHatUpdate) {
					name = jsonFieldsNameOfHatUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HatUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HatUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HatUpdateType as json.
func (s HatUpdateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HatUpdateType from json.
func (s *HatUpdateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HatUpdateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HatUpdateType(v) {
	case HatUpdateTypeDad:
		*s = HatUpdateTypeDad
	case HatUpdateTypeTrucker:
		*s = HatUpdateTypeTrucker
	case HatUpdateTypeSnapback:
		*s = HatUpdateTypeSnapback
	default:
		*s = HatUpdateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HatUpdateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HatUpdateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HatWearerRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HatWearerRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{

		e.FieldStart("favorite_color")
		s.FavoriteColor.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfHatWearerRead = [8]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_color",
	6: "favorite_dog_breed",
	7: "favorite_fish_breed",
}

// Decode decodes HatWearerRead from json.
func (s *HatWearerRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HatWearerRead to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_color":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.FavoriteColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_color\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HatWearerRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHatWearerRead) {
					name = jsonFieldsNameOfHatWearerRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HatWearerRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HatWearerRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HatWearerReadFavoriteCatBreed as json.
func (s HatWearerReadFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HatWearerReadFavoriteCatBreed from json.
func (s *HatWearerReadFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HatWearerReadFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HatWearerReadFavoriteCatBreed(v) {
	case HatWearerReadFavoriteCatBreedSiamese:
		*s = HatWearerReadFavoriteCatBreedSiamese
	case HatWearerReadFavoriteCatBreedBengal:
		*s = HatWearerReadFavoriteCatBreedBengal
	case HatWearerReadFavoriteCatBreedLion:
		*s = HatWearerReadFavoriteCatBreedLion
	case HatWearerReadFavoriteCatBreedTiger:
		*s = HatWearerReadFavoriteCatBreedTiger
	case HatWearerReadFavoriteCatBreedLeopard:
		*s = HatWearerReadFavoriteCatBreedLeopard
	case HatWearerReadFavoriteCatBreedOther:
		*s = HatWearerReadFavoriteCatBreedOther
	default:
		*s = HatWearerReadFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HatWearerReadFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HatWearerReadFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HatWearerReadFavoriteColor as json.
func (s HatWearerReadFavoriteColor) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HatWearerReadFavoriteColor from json.
func (s *HatWearerReadFavoriteColor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HatWearerReadFavoriteColor to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HatWearerReadFavoriteColor(v) {
	case HatWearerReadFavoriteColorRed:
		*s = HatWearerReadFavoriteColorRed
	case HatWearerReadFavoriteColorGreen:
		*s = HatWearerReadFavoriteColorGreen
	case HatWearerReadFavoriteColorBlue:
		*s = HatWearerReadFavoriteColorBlue
	default:
		*s = HatWearerReadFavoriteColor(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HatWearerReadFavoriteColor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HatWearerReadFavoriteColor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HatWearerReadFavoriteDogBreed as json.
func (s HatWearerReadFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HatWearerReadFavoriteDogBreed from json.
func (s *HatWearerReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HatWearerReadFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HatWearerReadFavoriteDogBreed(v) {
	case HatWearerReadFavoriteDogBreedKuro:
		*s = HatWearerReadFavoriteDogBreedKuro
	default:
		*s = HatWearerReadFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HatWearerReadFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HatWearerReadFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HatWearerReadFavoriteFishBreed as json.
func (s HatWearerReadFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HatWearerReadFavoriteFishBreed from json.
func (s *HatWearerReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HatWearerReadFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HatWearerReadFavoriteFishBreed(v) {
	case HatWearerReadFavoriteFishBreedGold:
		*s = HatWearerReadFavoriteFishBreedGold
	case HatWearerReadFavoriteFishBreedKoi:
		*s = HatWearerReadFavoriteFishBreedKoi
	case HatWearerReadFavoriteFishBreedShark:
		*s = HatWearerReadFavoriteFishBreedShark
	default:
		*s = HatWearerReadFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HatWearerReadFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HatWearerReadFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListAllTypesOKApplicationJSON as json.
func (s ListAllTypesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []AllTypesList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListAllTypesOKApplicationJSON from json.
func (s *ListAllTypesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAllTypesOKApplicationJSON to nil")
	}
	var unwrapped []AllTypesList
	if err := func() error {
		unwrapped = make([]AllTypesList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AllTypesList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListAllTypesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListAllTypesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAllTypesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListCategoryOKApplicationJSON as json.
func (s ListCategoryOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CategoryList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListCategoryOKApplicationJSON from json.
func (s *ListCategoryOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListCategoryOKApplicationJSON to nil")
	}
	var unwrapped []CategoryList
	if err := func() error {
		unwrapped = make([]CategoryList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CategoryList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListCategoryOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListCategoryOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListCategoryOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListCategoryPetsOKApplicationJSON as json.
func (s ListCategoryPetsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CategoryPetsList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListCategoryPetsOKApplicationJSON from json.
func (s *ListCategoryPetsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListCategoryPetsOKApplicationJSON to nil")
	}
	var unwrapped []CategoryPetsList
	if err := func() error {
		unwrapped = make([]CategoryPetsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CategoryPetsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListCategoryPetsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListCategoryPetsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListCategoryPetsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListHatOKApplicationJSON as json.
func (s ListHatOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []HatList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListHatOKApplicationJSON from json.
func (s *ListHatOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListHatOKApplicationJSON to nil")
	}
	var unwrapped []HatList
	if err := func() error {
		unwrapped = make([]HatList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HatList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListHatOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListHatOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListHatOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListPetCategoriesOKApplicationJSON as json.
func (s ListPetCategoriesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PetCategoriesList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListPetCategoriesOKApplicationJSON from json.
func (s *ListPetCategoriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPetCategoriesOKApplicationJSON to nil")
	}
	var unwrapped []PetCategoriesList
	if err := func() error {
		unwrapped = make([]PetCategoriesList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PetCategoriesList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListPetCategoriesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListPetCategoriesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListPetCategoriesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListPetFriendsOKApplicationJSON as json.
func (s ListPetFriendsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PetFriendsList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListPetFriendsOKApplicationJSON from json.
func (s *ListPetFriendsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPetFriendsOKApplicationJSON to nil")
	}
	var unwrapped []PetFriendsList
	if err := func() error {
		unwrapped = make([]PetFriendsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PetFriendsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListPetFriendsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListPetFriendsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListPetFriendsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListPetOKApplicationJSON as json.
func (s ListPetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PetList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListPetOKApplicationJSON from json.
func (s *ListPetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPetOKApplicationJSON to nil")
	}
	var unwrapped []PetList
	if err := func() error {
		unwrapped = make([]PetList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PetList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListPetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListPetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListPetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListPetRescuerOKApplicationJSON as json.
func (s ListPetRescuerOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PetRescuerList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListPetRescuerOKApplicationJSON from json.
func (s *ListPetRescuerOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPetRescuerOKApplicationJSON to nil")
	}
	var unwrapped []PetRescuerList
	if err := func() error {
		unwrapped = make([]PetRescuerList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PetRescuerList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListPetRescuerOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListPetRescuerOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListPetRescuerOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListUserAnimalsSavedOKApplicationJSON as json.
func (s ListUserAnimalsSavedOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []UserAnimalsSavedList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListUserAnimalsSavedOKApplicationJSON from json.
func (s *ListUserAnimalsSavedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserAnimalsSavedOKApplicationJSON to nil")
	}
	var unwrapped []UserAnimalsSavedList
	if err := func() error {
		unwrapped = make([]UserAnimalsSavedList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserAnimalsSavedList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserAnimalsSavedOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListUserAnimalsSavedOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListUserAnimalsSavedOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListUserOKApplicationJSON as json.
func (s ListUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []UserList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListUserOKApplicationJSON from json.
func (s *ListUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserOKApplicationJSON to nil")
	}
	var unwrapped []UserList
	if err := func() error {
		unwrapped = make([]UserList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListUserOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListUserOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListUserPetsOKApplicationJSON as json.
func (s ListUserPetsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []UserPetsList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListUserPetsOKApplicationJSON from json.
func (s *ListUserPetsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserPetsOKApplicationJSON to nil")
	}
	var unwrapped []UserPetsList
	if err := func() error {
		unwrapped = make([]UserPetsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserPetsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserPetsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListUserPetsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListUserPetsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserReqFavoriteDogBreed as json.
func (o OptCreateUserReqFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateUserReqFavoriteDogBreed from json.
func (o *OptCreateUserReqFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateUserReqFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateUserReqFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateUserReqFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserReqFavoriteFishBreed as json.
func (o OptCreateUserReqFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateUserReqFavoriteFishBreed from json.
func (o *OptCreateUserReqFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateUserReqFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateUserReqFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateUserReqFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HatWearerReadFavoriteDogBreed as json.
func (o OptHatWearerReadFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HatWearerReadFavoriteDogBreed from json.
func (o *OptHatWearerReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHatWearerReadFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHatWearerReadFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHatWearerReadFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HatWearerReadFavoriteFishBreed as json.
func (o OptHatWearerReadFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HatWearerReadFavoriteFishBreed from json.
func (o *OptHatWearerReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHatWearerReadFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHatWearerReadFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHatWearerReadFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetCreateOwnerFavoriteDogBreed as json.
func (o OptPetCreateOwnerFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PetCreateOwnerFavoriteDogBreed from json.
func (o *OptPetCreateOwnerFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPetCreateOwnerFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPetCreateOwnerFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPetCreateOwnerFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetCreateOwnerFavoriteFishBreed as json.
func (o OptPetCreateOwnerFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PetCreateOwnerFavoriteFishBreed from json.
func (o *OptPetCreateOwnerFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPetCreateOwnerFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPetCreateOwnerFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPetCreateOwnerFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetOwnerReadFavoriteDogBreed as json.
func (o OptPetOwnerReadFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PetOwnerReadFavoriteDogBreed from json.
func (o *OptPetOwnerReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPetOwnerReadFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPetOwnerReadFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPetOwnerReadFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetOwnerReadFavoriteFishBreed as json.
func (o OptPetOwnerReadFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PetOwnerReadFavoriteFishBreed from json.
func (o *OptPetOwnerReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPetOwnerReadFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPetOwnerReadFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPetOwnerReadFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetRescuerListFavoriteDogBreed as json.
func (o OptPetRescuerListFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PetRescuerListFavoriteDogBreed from json.
func (o *OptPetRescuerListFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPetRescuerListFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPetRescuerListFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPetRescuerListFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetRescuerListFavoriteFishBreed as json.
func (o OptPetRescuerListFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PetRescuerListFavoriteFishBreed from json.
func (o *OptPetRescuerListFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPetRescuerListFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPetRescuerListFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPetRescuerListFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAllTypesReqState as json.
func (o OptUpdateAllTypesReqState) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateAllTypesReqState from json.
func (o *OptUpdateAllTypesReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateAllTypesReqState to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateAllTypesReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateAllTypesReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserReqFavoriteCatBreed as json.
func (o OptUpdateUserReqFavoriteCatBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserReqFavoriteCatBreed from json.
func (o *OptUpdateUserReqFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserReqFavoriteCatBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUserReqFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUserReqFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserReqFavoriteDogBreed as json.
func (o OptUpdateUserReqFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserReqFavoriteDogBreed from json.
func (o *OptUpdateUserReqFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserReqFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUserReqFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUserReqFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserReqFavoriteFishBreed as json.
func (o OptUpdateUserReqFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserReqFavoriteFishBreed from json.
func (o *OptUpdateUserReqFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserReqFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUserReqFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUserReqFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBestFriendReadFavoriteDogBreed as json.
func (o OptUserBestFriendReadFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserBestFriendReadFavoriteDogBreed from json.
func (o *OptUserBestFriendReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserBestFriendReadFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserBestFriendReadFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserBestFriendReadFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBestFriendReadFavoriteFishBreed as json.
func (o OptUserBestFriendReadFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserBestFriendReadFavoriteFishBreed from json.
func (o *OptUserBestFriendReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserBestFriendReadFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserBestFriendReadFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserBestFriendReadFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserCreateFavoriteDogBreed as json.
func (o OptUserCreateFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserCreateFavoriteDogBreed from json.
func (o *OptUserCreateFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserCreateFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserCreateFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserCreateFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserCreateFavoriteFishBreed as json.
func (o OptUserCreateFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserCreateFavoriteFishBreed from json.
func (o *OptUserCreateFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserCreateFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserCreateFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserCreateFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserListFavoriteDogBreed as json.
func (o OptUserListFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserListFavoriteDogBreed from json.
func (o *OptUserListFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserListFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserListFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserListFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserListFavoriteFishBreed as json.
func (o OptUserListFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserListFavoriteFishBreed from json.
func (o *OptUserListFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserListFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserListFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserListFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserReadFavoriteDogBreed as json.
func (o OptUserReadFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserReadFavoriteDogBreed from json.
func (o *OptUserReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserReadFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserReadFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserReadFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserReadFavoriteFishBreed as json.
func (o OptUserReadFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserReadFavoriteFishBreed from json.
func (o *OptUserReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserReadFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserReadFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserReadFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserUpdateFavoriteDogBreed as json.
func (o OptUserUpdateFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserUpdateFavoriteDogBreed from json.
func (o *OptUserUpdateFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserUpdateFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserUpdateFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserUpdateFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserUpdateFavoriteFishBreed as json.
func (o OptUserUpdateFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserUpdateFavoriteFishBreed from json.
func (o *OptUserUpdateFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserUpdateFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserUpdateFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserUpdateFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetCategoriesList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetCategoriesList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Readonly.Set {
			e.FieldStart("readonly")
			s.Readonly.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetCategoriesList = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes PetCategoriesList from json.
func (s *PetCategoriesList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCategoriesList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			if err := func() error {
				s.Readonly.Reset()
				if err := s.Readonly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetCategoriesList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCategoriesList) {
					name = jsonFieldsNameOfPetCategoriesList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetCategoriesList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetCategoriesList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Categories != nil {
			e.FieldStart("categories")
			e.ArrStart()
			for _, elem := range s.Categories {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{

		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
}

var jsonFieldsNameOfPetCreate = [8]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "tag_id",
	5: "height",
	6: "categories",
	7: "owner",
}

// Decode decodes PetCreate from json.
func (s *PetCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "categories":
			if err := func() error {
				s.Categories = make([]PetCreateCategories, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PetCreateCategories
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCreate) {
					name = jsonFieldsNameOfPetCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetCreateCategories) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetCreateCategories) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Readonly.Set {
			e.FieldStart("readonly")
			s.Readonly.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetCreateCategories = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes PetCreateCategories from json.
func (s *PetCreateCategories) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateCategories to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			if err := func() error {
				s.Readonly.Reset()
				if err := s.Readonly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetCreateCategories")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCreateCategories) {
					name = jsonFieldsNameOfPetCreateCategories[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetCreateCategories) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetCreateCategories) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetCreateOwner) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetCreateOwner) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{

		e.FieldStart("favorite_color")
		s.FavoriteColor.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetCreateOwner = [8]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_color",
	6: "favorite_dog_breed",
	7: "favorite_fish_breed",
}

// Decode decodes PetCreateOwner from json.
func (s *PetCreateOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateOwner to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_color":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.FavoriteColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_color\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetCreateOwner")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCreateOwner) {
					name = jsonFieldsNameOfPetCreateOwner[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetCreateOwner) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetCreateOwner) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetCreateOwnerFavoriteCatBreed as json.
func (s PetCreateOwnerFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetCreateOwnerFavoriteCatBreed from json.
func (s *PetCreateOwnerFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateOwnerFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetCreateOwnerFavoriteCatBreed(v) {
	case PetCreateOwnerFavoriteCatBreedSiamese:
		*s = PetCreateOwnerFavoriteCatBreedSiamese
	case PetCreateOwnerFavoriteCatBreedBengal:
		*s = PetCreateOwnerFavoriteCatBreedBengal
	case PetCreateOwnerFavoriteCatBreedLion:
		*s = PetCreateOwnerFavoriteCatBreedLion
	case PetCreateOwnerFavoriteCatBreedTiger:
		*s = PetCreateOwnerFavoriteCatBreedTiger
	case PetCreateOwnerFavoriteCatBreedLeopard:
		*s = PetCreateOwnerFavoriteCatBreedLeopard
	case PetCreateOwnerFavoriteCatBreedOther:
		*s = PetCreateOwnerFavoriteCatBreedOther
	default:
		*s = PetCreateOwnerFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetCreateOwnerFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetCreateOwnerFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetCreateOwnerFavoriteColor as json.
func (s PetCreateOwnerFavoriteColor) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetCreateOwnerFavoriteColor from json.
func (s *PetCreateOwnerFavoriteColor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateOwnerFavoriteColor to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetCreateOwnerFavoriteColor(v) {
	case PetCreateOwnerFavoriteColorRed:
		*s = PetCreateOwnerFavoriteColorRed
	case PetCreateOwnerFavoriteColorGreen:
		*s = PetCreateOwnerFavoriteColorGreen
	case PetCreateOwnerFavoriteColorBlue:
		*s = PetCreateOwnerFavoriteColorBlue
	default:
		*s = PetCreateOwnerFavoriteColor(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetCreateOwnerFavoriteColor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetCreateOwnerFavoriteColor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetCreateOwnerFavoriteDogBreed as json.
func (s PetCreateOwnerFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetCreateOwnerFavoriteDogBreed from json.
func (s *PetCreateOwnerFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateOwnerFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetCreateOwnerFavoriteDogBreed(v) {
	case PetCreateOwnerFavoriteDogBreedKuro:
		*s = PetCreateOwnerFavoriteDogBreedKuro
	default:
		*s = PetCreateOwnerFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetCreateOwnerFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetCreateOwnerFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetCreateOwnerFavoriteFishBreed as json.
func (s PetCreateOwnerFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetCreateOwnerFavoriteFishBreed from json.
func (s *PetCreateOwnerFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateOwnerFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetCreateOwnerFavoriteFishBreed(v) {
	case PetCreateOwnerFavoriteFishBreedGold:
		*s = PetCreateOwnerFavoriteFishBreedGold
	case PetCreateOwnerFavoriteFishBreedKoi:
		*s = PetCreateOwnerFavoriteFishBreedKoi
	case PetCreateOwnerFavoriteFishBreedShark:
		*s = PetCreateOwnerFavoriteFishBreedShark
	default:
		*s = PetCreateOwnerFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetCreateOwnerFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetCreateOwnerFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetFriendsList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetFriendsList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetFriendsList = [6]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "tag_id",
	5: "height",
}

// Decode decodes PetFriendsList from json.
func (s *PetFriendsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetFriendsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetFriendsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetFriendsList) {
					name = jsonFieldsNameOfPetFriendsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetFriendsList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetFriendsList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetList = [6]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "tag_id",
	5: "height",
}

// Decode decodes PetList from json.
func (s *PetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetList) {
					name = jsonFieldsNameOfPetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetOwnerRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetOwnerRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{

		e.FieldStart("favorite_color")
		s.FavoriteColor.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetOwnerRead = [8]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_color",
	6: "favorite_dog_breed",
	7: "favorite_fish_breed",
}

// Decode decodes PetOwnerRead from json.
func (s *PetOwnerRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetOwnerRead to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_color":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.FavoriteColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_color\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetOwnerRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetOwnerRead) {
					name = jsonFieldsNameOfPetOwnerRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetOwnerRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetOwnerRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetOwnerReadFavoriteCatBreed as json.
func (s PetOwnerReadFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetOwnerReadFavoriteCatBreed from json.
func (s *PetOwnerReadFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetOwnerReadFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetOwnerReadFavoriteCatBreed(v) {
	case PetOwnerReadFavoriteCatBreedSiamese:
		*s = PetOwnerReadFavoriteCatBreedSiamese
	case PetOwnerReadFavoriteCatBreedBengal:
		*s = PetOwnerReadFavoriteCatBreedBengal
	case PetOwnerReadFavoriteCatBreedLion:
		*s = PetOwnerReadFavoriteCatBreedLion
	case PetOwnerReadFavoriteCatBreedTiger:
		*s = PetOwnerReadFavoriteCatBreedTiger
	case PetOwnerReadFavoriteCatBreedLeopard:
		*s = PetOwnerReadFavoriteCatBreedLeopard
	case PetOwnerReadFavoriteCatBreedOther:
		*s = PetOwnerReadFavoriteCatBreedOther
	default:
		*s = PetOwnerReadFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetOwnerReadFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetOwnerReadFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetOwnerReadFavoriteColor as json.
func (s PetOwnerReadFavoriteColor) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetOwnerReadFavoriteColor from json.
func (s *PetOwnerReadFavoriteColor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetOwnerReadFavoriteColor to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetOwnerReadFavoriteColor(v) {
	case PetOwnerReadFavoriteColorRed:
		*s = PetOwnerReadFavoriteColorRed
	case PetOwnerReadFavoriteColorGreen:
		*s = PetOwnerReadFavoriteColorGreen
	case PetOwnerReadFavoriteColorBlue:
		*s = PetOwnerReadFavoriteColorBlue
	default:
		*s = PetOwnerReadFavoriteColor(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetOwnerReadFavoriteColor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetOwnerReadFavoriteColor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetOwnerReadFavoriteDogBreed as json.
func (s PetOwnerReadFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetOwnerReadFavoriteDogBreed from json.
func (s *PetOwnerReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetOwnerReadFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetOwnerReadFavoriteDogBreed(v) {
	case PetOwnerReadFavoriteDogBreedKuro:
		*s = PetOwnerReadFavoriteDogBreedKuro
	default:
		*s = PetOwnerReadFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetOwnerReadFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetOwnerReadFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetOwnerReadFavoriteFishBreed as json.
func (s PetOwnerReadFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetOwnerReadFavoriteFishBreed from json.
func (s *PetOwnerReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetOwnerReadFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetOwnerReadFavoriteFishBreed(v) {
	case PetOwnerReadFavoriteFishBreedGold:
		*s = PetOwnerReadFavoriteFishBreedGold
	case PetOwnerReadFavoriteFishBreedKoi:
		*s = PetOwnerReadFavoriteFishBreedKoi
	case PetOwnerReadFavoriteFishBreedShark:
		*s = PetOwnerReadFavoriteFishBreedShark
	default:
		*s = PetOwnerReadFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetOwnerReadFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetOwnerReadFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetRead = [6]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "tag_id",
	5: "height",
}

// Decode decodes PetRead from json.
func (s *PetRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetRead) {
					name = jsonFieldsNameOfPetRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetRescuerList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetRescuerList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{

		e.FieldStart("favorite_color")
		s.FavoriteColor.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetRescuerList = [8]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_color",
	6: "favorite_dog_breed",
	7: "favorite_fish_breed",
}

// Decode decodes PetRescuerList from json.
func (s *PetRescuerList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetRescuerList to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_color":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.FavoriteColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_color\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetRescuerList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetRescuerList) {
					name = jsonFieldsNameOfPetRescuerList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetRescuerList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetRescuerList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetRescuerListFavoriteCatBreed as json.
func (s PetRescuerListFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetRescuerListFavoriteCatBreed from json.
func (s *PetRescuerListFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetRescuerListFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetRescuerListFavoriteCatBreed(v) {
	case PetRescuerListFavoriteCatBreedSiamese:
		*s = PetRescuerListFavoriteCatBreedSiamese
	case PetRescuerListFavoriteCatBreedBengal:
		*s = PetRescuerListFavoriteCatBreedBengal
	case PetRescuerListFavoriteCatBreedLion:
		*s = PetRescuerListFavoriteCatBreedLion
	case PetRescuerListFavoriteCatBreedTiger:
		*s = PetRescuerListFavoriteCatBreedTiger
	case PetRescuerListFavoriteCatBreedLeopard:
		*s = PetRescuerListFavoriteCatBreedLeopard
	case PetRescuerListFavoriteCatBreedOther:
		*s = PetRescuerListFavoriteCatBreedOther
	default:
		*s = PetRescuerListFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetRescuerListFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetRescuerListFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetRescuerListFavoriteColor as json.
func (s PetRescuerListFavoriteColor) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetRescuerListFavoriteColor from json.
func (s *PetRescuerListFavoriteColor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetRescuerListFavoriteColor to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetRescuerListFavoriteColor(v) {
	case PetRescuerListFavoriteColorRed:
		*s = PetRescuerListFavoriteColorRed
	case PetRescuerListFavoriteColorGreen:
		*s = PetRescuerListFavoriteColorGreen
	case PetRescuerListFavoriteColorBlue:
		*s = PetRescuerListFavoriteColorBlue
	default:
		*s = PetRescuerListFavoriteColor(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetRescuerListFavoriteColor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetRescuerListFavoriteColor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetRescuerListFavoriteDogBreed as json.
func (s PetRescuerListFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetRescuerListFavoriteDogBreed from json.
func (s *PetRescuerListFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetRescuerListFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetRescuerListFavoriteDogBreed(v) {
	case PetRescuerListFavoriteDogBreedKuro:
		*s = PetRescuerListFavoriteDogBreedKuro
	default:
		*s = PetRescuerListFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetRescuerListFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetRescuerListFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetRescuerListFavoriteFishBreed as json.
func (s PetRescuerListFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetRescuerListFavoriteFishBreed from json.
func (s *PetRescuerListFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetRescuerListFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetRescuerListFavoriteFishBreed(v) {
	case PetRescuerListFavoriteFishBreedGold:
		*s = PetRescuerListFavoriteFishBreedGold
	case PetRescuerListFavoriteFishBreedKoi:
		*s = PetRescuerListFavoriteFishBreedKoi
	case PetRescuerListFavoriteFishBreedShark:
		*s = PetRescuerListFavoriteFishBreedShark
	default:
		*s = PetRescuerListFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetRescuerListFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetRescuerListFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetUpdate = [6]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "tag_id",
	5: "height",
}

// Decode decodes PetUpdate from json.
func (s *PetUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetUpdate) {
					name = jsonFieldsNameOfPetUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R400) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R400) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR400 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R400 from json.
func (s *R400) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R400 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R400")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR400) {
					name = jsonFieldsNameOfR400[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R400) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R400) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R404) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R404) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR404 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R404 from json.
func (s *R404) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R404 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R404")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR404) {
					name = jsonFieldsNameOfR404[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R404) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R404) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R409) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R409) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR409 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R409 from json.
func (s *R409) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R409 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R409")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR409) {
					name = jsonFieldsNameOfR409[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R409) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R409) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R500) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R500) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR500 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R500 from json.
func (s *R500) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R500 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R500")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR500) {
					name = jsonFieldsNameOfR500[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R500) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R500) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateAllTypesReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateAllTypesReq) encodeFields(e *jx.Encoder) {
	{
		if s.Int.Set {
			e.FieldStart("int")
			s.Int.Encode(e)
		}
	}
	{
		if s.Int8.Set {
			e.FieldStart("int8")
			s.Int8.Encode(e)
		}
	}
	{
		if s.Int16.Set {
			e.FieldStart("int16")
			s.Int16.Encode(e)
		}
	}
	{
		if s.Int32.Set {
			e.FieldStart("int32")
			s.Int32.Encode(e)
		}
	}
	{
		if s.Int64.Set {
			e.FieldStart("int64")
			s.Int64.Encode(e)
		}
	}
	{
		if s.Uint.Set {
			e.FieldStart("uint")
			s.Uint.Encode(e)
		}
	}
	{
		if s.Uint8.Set {
			e.FieldStart("uint8")
			s.Uint8.Encode(e)
		}
	}
	{
		if s.Uint16.Set {
			e.FieldStart("uint16")
			s.Uint16.Encode(e)
		}
	}
	{
		if s.Uint32.Set {
			e.FieldStart("uint32")
			s.Uint32.Encode(e)
		}
	}
	{
		if s.Uint64.Set {
			e.FieldStart("uint64")
			s.Uint64.Encode(e)
		}
	}
	{
		if s.Float32.Set {
			e.FieldStart("float32")
			s.Float32.Encode(e)
		}
	}
	{
		if s.Float64.Set {
			e.FieldStart("float64")
			s.Float64.Encode(e)
		}
	}
	{
		if s.StringType.Set {
			e.FieldStart("string_type")
			s.StringType.Encode(e)
		}
	}
	{
		if s.Bool.Set {
			e.FieldStart("bool")
			s.Bool.Encode(e)
		}
	}
	{
		if s.UUID.Set {
			e.FieldStart("uuid")
			s.UUID.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("time")
			s.Time.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{

		e.FieldStart("bytes")
		e.Base64(s.Bytes)
	}
	{
		if s.Nilable.Set {
			e.FieldStart("nilable")
			s.Nilable.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateAllTypesReq = [20]string{
	0:  "int",
	1:  "int8",
	2:  "int16",
	3:  "int32",
	4:  "int64",
	5:  "uint",
	6:  "uint8",
	7:  "uint16",
	8:  "uint32",
	9:  "uint64",
	10: "float32",
	11: "float64",
	12: "string_type",
	13: "bool",
	14: "uuid",
	15: "time",
	16: "text",
	17: "state",
	18: "bytes",
	19: "nilable",
}

// Decode decodes UpdateAllTypesReq from json.
func (s *UpdateAllTypesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAllTypesReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "int":
			if err := func() error {
				s.Int.Reset()
				if err := s.Int.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int\"")
			}
		case "int8":
			if err := func() error {
				s.Int8.Reset()
				if err := s.Int8.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int8\"")
			}
		case "int16":
			if err := func() error {
				s.Int16.Reset()
				if err := s.Int16.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int16\"")
			}
		case "int32":
			if err := func() error {
				s.Int32.Reset()
				if err := s.Int32.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int32\"")
			}
		case "int64":
			if err := func() error {
				s.Int64.Reset()
				if err := s.Int64.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int64\"")
			}
		case "uint":
			if err := func() error {
				s.Uint.Reset()
				if err := s.Uint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint\"")
			}
		case "uint8":
			if err := func() error {
				s.Uint8.Reset()
				if err := s.Uint8.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint8\"")
			}
		case "uint16":
			if err := func() error {
				s.Uint16.Reset()
				if err := s.Uint16.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint16\"")
			}
		case "uint32":
			if err := func() error {
				s.Uint32.Reset()
				if err := s.Uint32.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint32\"")
			}
		case "uint64":
			if err := func() error {
				s.Uint64.Reset()
				if err := s.Uint64.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint64\"")
			}
		case "float32":
			if err := func() error {
				s.Float32.Reset()
				if err := s.Float32.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float32\"")
			}
		case "float64":
			if err := func() error {
				s.Float64.Reset()
				if err := s.Float64.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float64\"")
			}
		case "string_type":
			if err := func() error {
				s.StringType.Reset()
				if err := s.StringType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"string_type\"")
			}
		case "bool":
			if err := func() error {
				s.Bool.Reset()
				if err := s.Bool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bool\"")
			}
		case "uuid":
			if err := func() error {
				s.UUID.Reset()
				if err := s.UUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "bytes":
			if err := func() error {
				v, err := d.Base64()
				s.Bytes = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bytes\"")
			}
		case "nilable":
			if err := func() error {
				s.Nilable.Reset()
				if err := s.Nilable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nilable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateAllTypesReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateAllTypesReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAllTypesReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAllTypesReqState as json.
func (s UpdateAllTypesReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateAllTypesReqState from json.
func (s *UpdateAllTypesReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAllTypesReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateAllTypesReqState(v) {
	case UpdateAllTypesReqStateOn:
		*s = UpdateAllTypesReqStateOn
	case UpdateAllTypesReqStateOff:
		*s = UpdateAllTypesReqStateOff
	default:
		*s = UpdateAllTypesReqState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateAllTypesReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAllTypesReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCategoryReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCategoryReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Pets != nil {
			e.FieldStart("pets")
			e.ArrStart()
			for _, elem := range s.Pets {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateCategoryReq = [2]string{
	0: "name",
	1: "pets",
}

// Decode decodes UpdateCategoryReq from json.
func (s *UpdateCategoryReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCategoryReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "pets":
			if err := func() error {
				s.Pets = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Pets = append(s.Pets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCategoryReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCategoryReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCategoryReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHatReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHatReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Wearer.Set {
			e.FieldStart("wearer")
			s.Wearer.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateHatReq = [2]string{
	0: "name",
	1: "wearer",
}

// Decode decodes UpdateHatReq from json.
func (s *UpdateHatReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHatReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "wearer":
			if err := func() error {
				s.Wearer.Reset()
				if err := s.Wearer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wearer\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHatReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHatReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHatReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePetReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePetReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Categories != nil {
			e.FieldStart("categories")
			e.ArrStart()
			for _, elem := range s.Categories {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Owner.Set {
			e.FieldStart("owner")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Rescuer != nil {
			e.FieldStart("rescuer")
			e.ArrStart()
			for _, elem := range s.Rescuer {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Friends != nil {
			e.FieldStart("friends")
			e.ArrStart()
			for _, elem := range s.Friends {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdatePetReq = [9]string{
	0: "name",
	1: "weight",
	2: "birthday",
	3: "tag_id",
	4: "height",
	5: "categories",
	6: "owner",
	7: "rescuer",
	8: "friends",
}

// Decode decodes UpdatePetReq from json.
func (s *UpdatePetReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePetReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "categories":
			if err := func() error {
				s.Categories = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "rescuer":
			if err := func() error {
				s.Rescuer = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Rescuer = append(s.Rescuer, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rescuer\"")
			}
		case "friends":
			if err := func() error {
				s.Friends = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Friends = append(s.Friends, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friends\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePetReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePetReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePetReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateUserReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Age.Set {
			e.FieldStart("age")
			s.Age.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.FavoriteCatBreed.Set {
			e.FieldStart("favorite_cat_breed")
			s.FavoriteCatBreed.Encode(e)
		}
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
	{
		if s.Pets != nil {
			e.FieldStart("pets")
			e.ArrStart()
			for _, elem := range s.Pets {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AnimalsSaved != nil {
			e.FieldStart("animals_saved")
			e.ArrStart()
			for _, elem := range s.AnimalsSaved {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BestFriend.Set {
			e.FieldStart("best_friend")
			s.BestFriend.Encode(e)
		}
	}
	{
		if s.FavoriteHat.Set {
			e.FieldStart("favorite_hat")
			s.FavoriteHat.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateUserReq = [10]string{
	0: "name",
	1: "age",
	2: "height",
	3: "favorite_cat_breed",
	4: "favorite_dog_breed",
	5: "favorite_fish_breed",
	6: "pets",
	7: "animals_saved",
	8: "best_friend",
	9: "favorite_hat",
}

// Decode decodes UpdateUserReq from json.
func (s *UpdateUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			if err := func() error {
				s.Age.Reset()
				if err := s.Age.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			if err := func() error {
				s.FavoriteCatBreed.Reset()
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		case "pets":
			if err := func() error {
				s.Pets = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Pets = append(s.Pets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pets\"")
			}
		case "animals_saved":
			if err := func() error {
				s.AnimalsSaved = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.AnimalsSaved = append(s.AnimalsSaved, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"animals_saved\"")
			}
		case "best_friend":
			if err := func() error {
				s.BestFriend.Reset()
				if err := s.BestFriend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"best_friend\"")
			}
		case "favorite_hat":
			if err := func() error {
				s.FavoriteHat.Reset()
				if err := s.FavoriteHat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_hat\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUserReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserReqFavoriteCatBreed as json.
func (s UpdateUserReqFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateUserReqFavoriteCatBreed from json.
func (s *UpdateUserReqFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserReqFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserReqFavoriteCatBreed(v) {
	case UpdateUserReqFavoriteCatBreedSiamese:
		*s = UpdateUserReqFavoriteCatBreedSiamese
	case UpdateUserReqFavoriteCatBreedBengal:
		*s = UpdateUserReqFavoriteCatBreedBengal
	case UpdateUserReqFavoriteCatBreedLion:
		*s = UpdateUserReqFavoriteCatBreedLion
	case UpdateUserReqFavoriteCatBreedTiger:
		*s = UpdateUserReqFavoriteCatBreedTiger
	case UpdateUserReqFavoriteCatBreedLeopard:
		*s = UpdateUserReqFavoriteCatBreedLeopard
	case UpdateUserReqFavoriteCatBreedOther:
		*s = UpdateUserReqFavoriteCatBreedOther
	default:
		*s = UpdateUserReqFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUserReqFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserReqFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserReqFavoriteDogBreed as json.
func (s UpdateUserReqFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateUserReqFavoriteDogBreed from json.
func (s *UpdateUserReqFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserReqFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserReqFavoriteDogBreed(v) {
	case UpdateUserReqFavoriteDogBreedKuro:
		*s = UpdateUserReqFavoriteDogBreedKuro
	default:
		*s = UpdateUserReqFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUserReqFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserReqFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserReqFavoriteFishBreed as json.
func (s UpdateUserReqFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateUserReqFavoriteFishBreed from json.
func (s *UpdateUserReqFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserReqFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserReqFavoriteFishBreed(v) {
	case UpdateUserReqFavoriteFishBreedGold:
		*s = UpdateUserReqFavoriteFishBreedGold
	case UpdateUserReqFavoriteFishBreedKoi:
		*s = UpdateUserReqFavoriteFishBreedKoi
	case UpdateUserReqFavoriteFishBreedShark:
		*s = UpdateUserReqFavoriteFishBreedShark
	default:
		*s = UpdateUserReqFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUserReqFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserReqFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserAnimalsSavedList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserAnimalsSavedList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserAnimalsSavedList = [6]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "tag_id",
	5: "height",
}

// Decode decodes UserAnimalsSavedList from json.
func (s *UserAnimalsSavedList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAnimalsSavedList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAnimalsSavedList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserAnimalsSavedList) {
					name = jsonFieldsNameOfUserAnimalsSavedList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserAnimalsSavedList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAnimalsSavedList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserBestFriendRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserBestFriendRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{

		e.FieldStart("favorite_color")
		s.FavoriteColor.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserBestFriendRead = [8]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_color",
	6: "favorite_dog_breed",
	7: "favorite_fish_breed",
}

// Decode decodes UserBestFriendRead from json.
func (s *UserBestFriendRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBestFriendRead to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_color":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.FavoriteColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_color\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserBestFriendRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserBestFriendRead) {
					name = jsonFieldsNameOfUserBestFriendRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserBestFriendRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserBestFriendRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBestFriendReadFavoriteCatBreed as json.
func (s UserBestFriendReadFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserBestFriendReadFavoriteCatBreed from json.
func (s *UserBestFriendReadFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBestFriendReadFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserBestFriendReadFavoriteCatBreed(v) {
	case UserBestFriendReadFavoriteCatBreedSiamese:
		*s = UserBestFriendReadFavoriteCatBreedSiamese
	case UserBestFriendReadFavoriteCatBreedBengal:
		*s = UserBestFriendReadFavoriteCatBreedBengal
	case UserBestFriendReadFavoriteCatBreedLion:
		*s = UserBestFriendReadFavoriteCatBreedLion
	case UserBestFriendReadFavoriteCatBreedTiger:
		*s = UserBestFriendReadFavoriteCatBreedTiger
	case UserBestFriendReadFavoriteCatBreedLeopard:
		*s = UserBestFriendReadFavoriteCatBreedLeopard
	case UserBestFriendReadFavoriteCatBreedOther:
		*s = UserBestFriendReadFavoriteCatBreedOther
	default:
		*s = UserBestFriendReadFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserBestFriendReadFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserBestFriendReadFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBestFriendReadFavoriteColor as json.
func (s UserBestFriendReadFavoriteColor) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserBestFriendReadFavoriteColor from json.
func (s *UserBestFriendReadFavoriteColor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBestFriendReadFavoriteColor to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserBestFriendReadFavoriteColor(v) {
	case UserBestFriendReadFavoriteColorRed:
		*s = UserBestFriendReadFavoriteColorRed
	case UserBestFriendReadFavoriteColorGreen:
		*s = UserBestFriendReadFavoriteColorGreen
	case UserBestFriendReadFavoriteColorBlue:
		*s = UserBestFriendReadFavoriteColorBlue
	default:
		*s = UserBestFriendReadFavoriteColor(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserBestFriendReadFavoriteColor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserBestFriendReadFavoriteColor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBestFriendReadFavoriteDogBreed as json.
func (s UserBestFriendReadFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserBestFriendReadFavoriteDogBreed from json.
func (s *UserBestFriendReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBestFriendReadFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserBestFriendReadFavoriteDogBreed(v) {
	case UserBestFriendReadFavoriteDogBreedKuro:
		*s = UserBestFriendReadFavoriteDogBreedKuro
	default:
		*s = UserBestFriendReadFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserBestFriendReadFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserBestFriendReadFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBestFriendReadFavoriteFishBreed as json.
func (s UserBestFriendReadFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserBestFriendReadFavoriteFishBreed from json.
func (s *UserBestFriendReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBestFriendReadFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserBestFriendReadFavoriteFishBreed(v) {
	case UserBestFriendReadFavoriteFishBreedGold:
		*s = UserBestFriendReadFavoriteFishBreedGold
	case UserBestFriendReadFavoriteFishBreedKoi:
		*s = UserBestFriendReadFavoriteFishBreedKoi
	case UserBestFriendReadFavoriteFishBreedShark:
		*s = UserBestFriendReadFavoriteFishBreedShark
	default:
		*s = UserBestFriendReadFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserBestFriendReadFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserBestFriendReadFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{

		e.FieldStart("favorite_color")
		s.FavoriteColor.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserCreate = [8]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_color",
	6: "favorite_dog_breed",
	7: "favorite_fish_breed",
}

// Decode decodes UserCreate from json.
func (s *UserCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreate to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_color":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.FavoriteColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_color\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserCreate) {
					name = jsonFieldsNameOfUserCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserCreateFavoriteCatBreed as json.
func (s UserCreateFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserCreateFavoriteCatBreed from json.
func (s *UserCreateFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreateFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserCreateFavoriteCatBreed(v) {
	case UserCreateFavoriteCatBreedSiamese:
		*s = UserCreateFavoriteCatBreedSiamese
	case UserCreateFavoriteCatBreedBengal:
		*s = UserCreateFavoriteCatBreedBengal
	case UserCreateFavoriteCatBreedLion:
		*s = UserCreateFavoriteCatBreedLion
	case UserCreateFavoriteCatBreedTiger:
		*s = UserCreateFavoriteCatBreedTiger
	case UserCreateFavoriteCatBreedLeopard:
		*s = UserCreateFavoriteCatBreedLeopard
	case UserCreateFavoriteCatBreedOther:
		*s = UserCreateFavoriteCatBreedOther
	default:
		*s = UserCreateFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserCreateFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserCreateFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserCreateFavoriteColor as json.
func (s UserCreateFavoriteColor) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserCreateFavoriteColor from json.
func (s *UserCreateFavoriteColor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreateFavoriteColor to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserCreateFavoriteColor(v) {
	case UserCreateFavoriteColorRed:
		*s = UserCreateFavoriteColorRed
	case UserCreateFavoriteColorGreen:
		*s = UserCreateFavoriteColorGreen
	case UserCreateFavoriteColorBlue:
		*s = UserCreateFavoriteColorBlue
	default:
		*s = UserCreateFavoriteColor(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserCreateFavoriteColor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserCreateFavoriteColor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserCreateFavoriteDogBreed as json.
func (s UserCreateFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserCreateFavoriteDogBreed from json.
func (s *UserCreateFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreateFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserCreateFavoriteDogBreed(v) {
	case UserCreateFavoriteDogBreedKuro:
		*s = UserCreateFavoriteDogBreedKuro
	default:
		*s = UserCreateFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserCreateFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserCreateFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserCreateFavoriteFishBreed as json.
func (s UserCreateFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserCreateFavoriteFishBreed from json.
func (s *UserCreateFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreateFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserCreateFavoriteFishBreed(v) {
	case UserCreateFavoriteFishBreedGold:
		*s = UserCreateFavoriteFishBreedGold
	case UserCreateFavoriteFishBreedKoi:
		*s = UserCreateFavoriteFishBreedKoi
	case UserCreateFavoriteFishBreedShark:
		*s = UserCreateFavoriteFishBreedShark
	default:
		*s = UserCreateFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserCreateFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserCreateFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserFavoriteHatRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserFavoriteHatRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfUserFavoriteHatRead = [3]string{
	0: "id",
	1: "name",
	2: "type",
}

// Decode decodes UserFavoriteHatRead from json.
func (s *UserFavoriteHatRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserFavoriteHatRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserFavoriteHatRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserFavoriteHatRead) {
					name = jsonFieldsNameOfUserFavoriteHatRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserFavoriteHatRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserFavoriteHatRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserFavoriteHatReadType as json.
func (s UserFavoriteHatReadType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserFavoriteHatReadType from json.
func (s *UserFavoriteHatReadType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserFavoriteHatReadType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserFavoriteHatReadType(v) {
	case UserFavoriteHatReadTypeDad:
		*s = UserFavoriteHatReadTypeDad
	case UserFavoriteHatReadTypeTrucker:
		*s = UserFavoriteHatReadTypeTrucker
	case UserFavoriteHatReadTypeSnapback:
		*s = UserFavoriteHatReadTypeSnapback
	default:
		*s = UserFavoriteHatReadType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserFavoriteHatReadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserFavoriteHatReadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{

		e.FieldStart("favorite_color")
		s.FavoriteColor.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserList = [8]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_color",
	6: "favorite_dog_breed",
	7: "favorite_fish_breed",
}

// Decode decodes UserList from json.
func (s *UserList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserList to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_color":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.FavoriteColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_color\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserList) {
					name = jsonFieldsNameOfUserList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserListFavoriteCatBreed as json.
func (s UserListFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserListFavoriteCatBreed from json.
func (s *UserListFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserListFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserListFavoriteCatBreed(v) {
	case UserListFavoriteCatBreedSiamese:
		*s = UserListFavoriteCatBreedSiamese
	case UserListFavoriteCatBreedBengal:
		*s = UserListFavoriteCatBreedBengal
	case UserListFavoriteCatBreedLion:
		*s = UserListFavoriteCatBreedLion
	case UserListFavoriteCatBreedTiger:
		*s = UserListFavoriteCatBreedTiger
	case UserListFavoriteCatBreedLeopard:
		*s = UserListFavoriteCatBreedLeopard
	case UserListFavoriteCatBreedOther:
		*s = UserListFavoriteCatBreedOther
	default:
		*s = UserListFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserListFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserListFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserListFavoriteColor as json.
func (s UserListFavoriteColor) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserListFavoriteColor from json.
func (s *UserListFavoriteColor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserListFavoriteColor to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserListFavoriteColor(v) {
	case UserListFavoriteColorRed:
		*s = UserListFavoriteColorRed
	case UserListFavoriteColorGreen:
		*s = UserListFavoriteColorGreen
	case UserListFavoriteColorBlue:
		*s = UserListFavoriteColorBlue
	default:
		*s = UserListFavoriteColor(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserListFavoriteColor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserListFavoriteColor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserListFavoriteDogBreed as json.
func (s UserListFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserListFavoriteDogBreed from json.
func (s *UserListFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserListFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserListFavoriteDogBreed(v) {
	case UserListFavoriteDogBreedKuro:
		*s = UserListFavoriteDogBreedKuro
	default:
		*s = UserListFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserListFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserListFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserListFavoriteFishBreed as json.
func (s UserListFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserListFavoriteFishBreed from json.
func (s *UserListFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserListFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserListFavoriteFishBreed(v) {
	case UserListFavoriteFishBreedGold:
		*s = UserListFavoriteFishBreedGold
	case UserListFavoriteFishBreedKoi:
		*s = UserListFavoriteFishBreedKoi
	case UserListFavoriteFishBreedShark:
		*s = UserListFavoriteFishBreedShark
	default:
		*s = UserListFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserListFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserListFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserPetsList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserPetsList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserPetsList = [6]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "tag_id",
	5: "height",
}

// Decode decodes UserPetsList from json.
func (s *UserPetsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserPetsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserPetsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserPetsList) {
					name = jsonFieldsNameOfUserPetsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserPetsList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserPetsList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{

		e.FieldStart("favorite_color")
		s.FavoriteColor.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserRead = [8]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_color",
	6: "favorite_dog_breed",
	7: "favorite_fish_breed",
}

// Decode decodes UserRead from json.
func (s *UserRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserRead to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_color":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.FavoriteColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_color\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserRead) {
					name = jsonFieldsNameOfUserRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserReadFavoriteCatBreed as json.
func (s UserReadFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserReadFavoriteCatBreed from json.
func (s *UserReadFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserReadFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserReadFavoriteCatBreed(v) {
	case UserReadFavoriteCatBreedSiamese:
		*s = UserReadFavoriteCatBreedSiamese
	case UserReadFavoriteCatBreedBengal:
		*s = UserReadFavoriteCatBreedBengal
	case UserReadFavoriteCatBreedLion:
		*s = UserReadFavoriteCatBreedLion
	case UserReadFavoriteCatBreedTiger:
		*s = UserReadFavoriteCatBreedTiger
	case UserReadFavoriteCatBreedLeopard:
		*s = UserReadFavoriteCatBreedLeopard
	case UserReadFavoriteCatBreedOther:
		*s = UserReadFavoriteCatBreedOther
	default:
		*s = UserReadFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserReadFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserReadFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserReadFavoriteColor as json.
func (s UserReadFavoriteColor) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserReadFavoriteColor from json.
func (s *UserReadFavoriteColor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserReadFavoriteColor to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserReadFavoriteColor(v) {
	case UserReadFavoriteColorRed:
		*s = UserReadFavoriteColorRed
	case UserReadFavoriteColorGreen:
		*s = UserReadFavoriteColorGreen
	case UserReadFavoriteColorBlue:
		*s = UserReadFavoriteColorBlue
	default:
		*s = UserReadFavoriteColor(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserReadFavoriteColor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserReadFavoriteColor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserReadFavoriteDogBreed as json.
func (s UserReadFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserReadFavoriteDogBreed from json.
func (s *UserReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserReadFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserReadFavoriteDogBreed(v) {
	case UserReadFavoriteDogBreedKuro:
		*s = UserReadFavoriteDogBreedKuro
	default:
		*s = UserReadFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserReadFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserReadFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserReadFavoriteFishBreed as json.
func (s UserReadFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserReadFavoriteFishBreed from json.
func (s *UserReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserReadFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserReadFavoriteFishBreed(v) {
	case UserReadFavoriteFishBreedGold:
		*s = UserReadFavoriteFishBreedGold
	case UserReadFavoriteFishBreedKoi:
		*s = UserReadFavoriteFishBreedKoi
	case UserReadFavoriteFishBreedShark:
		*s = UserReadFavoriteFishBreedShark
	default:
		*s = UserReadFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserReadFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserReadFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{

		e.FieldStart("favorite_color")
		s.FavoriteColor.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserUpdate = [8]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_color",
	6: "favorite_dog_breed",
	7: "favorite_fish_breed",
}

// Decode decodes UserUpdate from json.
func (s *UserUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUpdate to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_color":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.FavoriteColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_color\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserUpdate) {
					name = jsonFieldsNameOfUserUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserUpdateFavoriteCatBreed as json.
func (s UserUpdateFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserUpdateFavoriteCatBreed from json.
func (s *UserUpdateFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUpdateFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserUpdateFavoriteCatBreed(v) {
	case UserUpdateFavoriteCatBreedSiamese:
		*s = UserUpdateFavoriteCatBreedSiamese
	case UserUpdateFavoriteCatBreedBengal:
		*s = UserUpdateFavoriteCatBreedBengal
	case UserUpdateFavoriteCatBreedLion:
		*s = UserUpdateFavoriteCatBreedLion
	case UserUpdateFavoriteCatBreedTiger:
		*s = UserUpdateFavoriteCatBreedTiger
	case UserUpdateFavoriteCatBreedLeopard:
		*s = UserUpdateFavoriteCatBreedLeopard
	case UserUpdateFavoriteCatBreedOther:
		*s = UserUpdateFavoriteCatBreedOther
	default:
		*s = UserUpdateFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserUpdateFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserUpdateFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserUpdateFavoriteColor as json.
func (s UserUpdateFavoriteColor) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserUpdateFavoriteColor from json.
func (s *UserUpdateFavoriteColor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUpdateFavoriteColor to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserUpdateFavoriteColor(v) {
	case UserUpdateFavoriteColorRed:
		*s = UserUpdateFavoriteColorRed
	case UserUpdateFavoriteColorGreen:
		*s = UserUpdateFavoriteColorGreen
	case UserUpdateFavoriteColorBlue:
		*s = UserUpdateFavoriteColorBlue
	default:
		*s = UserUpdateFavoriteColor(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserUpdateFavoriteColor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserUpdateFavoriteColor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserUpdateFavoriteDogBreed as json.
func (s UserUpdateFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserUpdateFavoriteDogBreed from json.
func (s *UserUpdateFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUpdateFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserUpdateFavoriteDogBreed(v) {
	case UserUpdateFavoriteDogBreedKuro:
		*s = UserUpdateFavoriteDogBreedKuro
	default:
		*s = UserUpdateFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserUpdateFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserUpdateFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserUpdateFavoriteFishBreed as json.
func (s UserUpdateFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserUpdateFavoriteFishBreed from json.
func (s *UserUpdateFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUpdateFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserUpdateFavoriteFishBreed(v) {
	case UserUpdateFavoriteFishBreedGold:
		*s = UserUpdateFavoriteFishBreedGold
	case UserUpdateFavoriteFishBreedKoi:
		*s = UserUpdateFavoriteFishBreedKoi
	case UserUpdateFavoriteFishBreedShark:
		*s = UserUpdateFavoriteFishBreedShark
	default:
		*s = UserUpdateFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserUpdateFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserUpdateFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
