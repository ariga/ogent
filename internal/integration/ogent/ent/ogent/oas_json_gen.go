// Code generated by ogen, DO NOT EDIT.

package ogent

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AllTypesCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AllTypesCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{

		e.FieldStart("int")
		e.Int(s.Int)
	}
	{

		e.FieldStart("int8")
		e.Int32(s.Int8)
	}
	{

		e.FieldStart("int16")
		e.Int32(s.Int16)
	}
	{

		e.FieldStart("int32")
		e.Int32(s.Int32)
	}
	{

		e.FieldStart("int64")
		e.Int64(s.Int64)
	}
	{

		e.FieldStart("uint")
		e.Int64(s.Uint)
	}
	{

		e.FieldStart("uint8")
		e.Int32(s.Uint8)
	}
	{

		e.FieldStart("uint16")
		e.Int32(s.Uint16)
	}
	{

		e.FieldStart("uint32")
		e.Int64(s.Uint32)
	}
	{

		e.FieldStart("uint64")
		e.Int64(s.Uint64)
	}
	{

		e.FieldStart("float32")
		e.Float32(s.Float32)
	}
	{

		e.FieldStart("float64")
		e.Float64(s.Float64)
	}
	{

		e.FieldStart("string_type")
		e.Str(s.StringType)
	}
	{

		e.FieldStart("bool")
		e.Bool(s.Bool)
	}
	{

		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{

		e.FieldStart("time")
		json.EncodeDateTime(e, s.Time)
	}
	{

		e.FieldStart("text")
		e.Str(s.Text)
	}
	{

		e.FieldStart("state")
		s.State.Encode(e)
	}
	{

		e.FieldStart("bytes")
		e.Base64(s.Bytes)
	}
}

var jsonFieldsNameOfAllTypesCreate = [20]string{
	0:  "id",
	1:  "int",
	2:  "int8",
	3:  "int16",
	4:  "int32",
	5:  "int64",
	6:  "uint",
	7:  "uint8",
	8:  "uint16",
	9:  "uint32",
	10: "uint64",
	11: "float32",
	12: "float64",
	13: "string_type",
	14: "bool",
	15: "uuid",
	16: "time",
	17: "text",
	18: "state",
	19: "bytes",
}

// Decode decodes AllTypesCreate from json.
func (s *AllTypesCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesCreate to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "int":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Int = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int\"")
			}
		case "int8":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Int8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int8\"")
			}
		case "int16":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Int16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int16\"")
			}
		case "int32":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Int32 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int32\"")
			}
		case "int64":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.Int64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int64\"")
			}
		case "uint":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int64()
				s.Uint = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint\"")
			}
		case "uint8":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Uint8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint8\"")
			}
		case "uint16":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Uint16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint16\"")
			}
		case "uint32":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Uint32 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint32\"")
			}
		case "uint64":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Uint64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint64\"")
			}
		case "float32":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Float32()
				s.Float32 = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float32\"")
			}
		case "float64":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Float64 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float64\"")
			}
		case "string_type":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StringType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"string_type\"")
			}
		case "bool":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Bool = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bool\"")
			}
		case "uuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "time":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "text":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "state":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "bytes":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Base64()
				s.Bytes = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AllTypesCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAllTypesCreate) {
					name = jsonFieldsNameOfAllTypesCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AllTypesCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AllTypesCreateState as json.
func (s AllTypesCreateState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AllTypesCreateState from json.
func (s *AllTypesCreateState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesCreateState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AllTypesCreateState(v) {
	case AllTypesCreateStateOn:
		*s = AllTypesCreateStateOn
	case AllTypesCreateStateOff:
		*s = AllTypesCreateStateOff
	default:
		*s = AllTypesCreateState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AllTypesCreateState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesCreateState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AllTypesList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AllTypesList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{

		e.FieldStart("int")
		e.Int(s.Int)
	}
	{

		e.FieldStart("int8")
		e.Int32(s.Int8)
	}
	{

		e.FieldStart("int16")
		e.Int32(s.Int16)
	}
	{

		e.FieldStart("int32")
		e.Int32(s.Int32)
	}
	{

		e.FieldStart("int64")
		e.Int64(s.Int64)
	}
	{

		e.FieldStart("uint")
		e.Int64(s.Uint)
	}
	{

		e.FieldStart("uint8")
		e.Int32(s.Uint8)
	}
	{

		e.FieldStart("uint16")
		e.Int32(s.Uint16)
	}
	{

		e.FieldStart("uint32")
		e.Int64(s.Uint32)
	}
	{

		e.FieldStart("uint64")
		e.Int64(s.Uint64)
	}
	{

		e.FieldStart("float32")
		e.Float32(s.Float32)
	}
	{

		e.FieldStart("float64")
		e.Float64(s.Float64)
	}
	{

		e.FieldStart("string_type")
		e.Str(s.StringType)
	}
	{

		e.FieldStart("bool")
		e.Bool(s.Bool)
	}
	{

		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{

		e.FieldStart("time")
		json.EncodeDateTime(e, s.Time)
	}
	{

		e.FieldStart("text")
		e.Str(s.Text)
	}
	{

		e.FieldStart("state")
		s.State.Encode(e)
	}
	{

		e.FieldStart("bytes")
		e.Base64(s.Bytes)
	}
}

var jsonFieldsNameOfAllTypesList = [20]string{
	0:  "id",
	1:  "int",
	2:  "int8",
	3:  "int16",
	4:  "int32",
	5:  "int64",
	6:  "uint",
	7:  "uint8",
	8:  "uint16",
	9:  "uint32",
	10: "uint64",
	11: "float32",
	12: "float64",
	13: "string_type",
	14: "bool",
	15: "uuid",
	16: "time",
	17: "text",
	18: "state",
	19: "bytes",
}

// Decode decodes AllTypesList from json.
func (s *AllTypesList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesList to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "int":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Int = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int\"")
			}
		case "int8":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Int8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int8\"")
			}
		case "int16":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Int16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int16\"")
			}
		case "int32":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Int32 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int32\"")
			}
		case "int64":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.Int64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int64\"")
			}
		case "uint":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int64()
				s.Uint = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint\"")
			}
		case "uint8":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Uint8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint8\"")
			}
		case "uint16":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Uint16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint16\"")
			}
		case "uint32":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Uint32 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint32\"")
			}
		case "uint64":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Uint64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint64\"")
			}
		case "float32":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Float32()
				s.Float32 = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float32\"")
			}
		case "float64":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Float64 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float64\"")
			}
		case "string_type":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StringType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"string_type\"")
			}
		case "bool":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Bool = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bool\"")
			}
		case "uuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "time":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "text":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "state":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "bytes":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Base64()
				s.Bytes = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AllTypesList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAllTypesList) {
					name = jsonFieldsNameOfAllTypesList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AllTypesList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AllTypesListState as json.
func (s AllTypesListState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AllTypesListState from json.
func (s *AllTypesListState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesListState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AllTypesListState(v) {
	case AllTypesListStateOn:
		*s = AllTypesListStateOn
	case AllTypesListStateOff:
		*s = AllTypesListStateOff
	default:
		*s = AllTypesListState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AllTypesListState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesListState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AllTypesRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AllTypesRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{

		e.FieldStart("int")
		e.Int(s.Int)
	}
	{

		e.FieldStart("int8")
		e.Int32(s.Int8)
	}
	{

		e.FieldStart("int16")
		e.Int32(s.Int16)
	}
	{

		e.FieldStart("int32")
		e.Int32(s.Int32)
	}
	{

		e.FieldStart("int64")
		e.Int64(s.Int64)
	}
	{

		e.FieldStart("uint")
		e.Int64(s.Uint)
	}
	{

		e.FieldStart("uint8")
		e.Int32(s.Uint8)
	}
	{

		e.FieldStart("uint16")
		e.Int32(s.Uint16)
	}
	{

		e.FieldStart("uint32")
		e.Int64(s.Uint32)
	}
	{

		e.FieldStart("uint64")
		e.Int64(s.Uint64)
	}
	{

		e.FieldStart("float32")
		e.Float32(s.Float32)
	}
	{

		e.FieldStart("float64")
		e.Float64(s.Float64)
	}
	{

		e.FieldStart("string_type")
		e.Str(s.StringType)
	}
	{

		e.FieldStart("bool")
		e.Bool(s.Bool)
	}
	{

		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{

		e.FieldStart("time")
		json.EncodeDateTime(e, s.Time)
	}
	{

		e.FieldStart("text")
		e.Str(s.Text)
	}
	{

		e.FieldStart("state")
		s.State.Encode(e)
	}
	{

		e.FieldStart("bytes")
		e.Base64(s.Bytes)
	}
}

var jsonFieldsNameOfAllTypesRead = [20]string{
	0:  "id",
	1:  "int",
	2:  "int8",
	3:  "int16",
	4:  "int32",
	5:  "int64",
	6:  "uint",
	7:  "uint8",
	8:  "uint16",
	9:  "uint32",
	10: "uint64",
	11: "float32",
	12: "float64",
	13: "string_type",
	14: "bool",
	15: "uuid",
	16: "time",
	17: "text",
	18: "state",
	19: "bytes",
}

// Decode decodes AllTypesRead from json.
func (s *AllTypesRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesRead to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "int":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Int = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int\"")
			}
		case "int8":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Int8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int8\"")
			}
		case "int16":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Int16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int16\"")
			}
		case "int32":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Int32 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int32\"")
			}
		case "int64":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.Int64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int64\"")
			}
		case "uint":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int64()
				s.Uint = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint\"")
			}
		case "uint8":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Uint8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint8\"")
			}
		case "uint16":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Uint16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint16\"")
			}
		case "uint32":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Uint32 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint32\"")
			}
		case "uint64":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Uint64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint64\"")
			}
		case "float32":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Float32()
				s.Float32 = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float32\"")
			}
		case "float64":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Float64 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float64\"")
			}
		case "string_type":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StringType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"string_type\"")
			}
		case "bool":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Bool = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bool\"")
			}
		case "uuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "time":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "text":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "state":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "bytes":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Base64()
				s.Bytes = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AllTypesRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAllTypesRead) {
					name = jsonFieldsNameOfAllTypesRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AllTypesRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AllTypesReadState as json.
func (s AllTypesReadState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AllTypesReadState from json.
func (s *AllTypesReadState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesReadState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AllTypesReadState(v) {
	case AllTypesReadStateOn:
		*s = AllTypesReadStateOn
	case AllTypesReadStateOff:
		*s = AllTypesReadStateOff
	default:
		*s = AllTypesReadState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AllTypesReadState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesReadState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AllTypesUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AllTypesUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{

		e.FieldStart("int")
		e.Int(s.Int)
	}
	{

		e.FieldStart("int8")
		e.Int32(s.Int8)
	}
	{

		e.FieldStart("int16")
		e.Int32(s.Int16)
	}
	{

		e.FieldStart("int32")
		e.Int32(s.Int32)
	}
	{

		e.FieldStart("int64")
		e.Int64(s.Int64)
	}
	{

		e.FieldStart("uint")
		e.Int64(s.Uint)
	}
	{

		e.FieldStart("uint8")
		e.Int32(s.Uint8)
	}
	{

		e.FieldStart("uint16")
		e.Int32(s.Uint16)
	}
	{

		e.FieldStart("uint32")
		e.Int64(s.Uint32)
	}
	{

		e.FieldStart("uint64")
		e.Int64(s.Uint64)
	}
	{

		e.FieldStart("float32")
		e.Float32(s.Float32)
	}
	{

		e.FieldStart("float64")
		e.Float64(s.Float64)
	}
	{

		e.FieldStart("string_type")
		e.Str(s.StringType)
	}
	{

		e.FieldStart("bool")
		e.Bool(s.Bool)
	}
	{

		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{

		e.FieldStart("time")
		json.EncodeDateTime(e, s.Time)
	}
	{

		e.FieldStart("text")
		e.Str(s.Text)
	}
	{

		e.FieldStart("state")
		s.State.Encode(e)
	}
	{

		e.FieldStart("bytes")
		e.Base64(s.Bytes)
	}
}

var jsonFieldsNameOfAllTypesUpdate = [20]string{
	0:  "id",
	1:  "int",
	2:  "int8",
	3:  "int16",
	4:  "int32",
	5:  "int64",
	6:  "uint",
	7:  "uint8",
	8:  "uint16",
	9:  "uint32",
	10: "uint64",
	11: "float32",
	12: "float64",
	13: "string_type",
	14: "bool",
	15: "uuid",
	16: "time",
	17: "text",
	18: "state",
	19: "bytes",
}

// Decode decodes AllTypesUpdate from json.
func (s *AllTypesUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesUpdate to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "int":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Int = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int\"")
			}
		case "int8":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Int8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int8\"")
			}
		case "int16":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Int16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int16\"")
			}
		case "int32":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Int32 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int32\"")
			}
		case "int64":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.Int64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int64\"")
			}
		case "uint":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int64()
				s.Uint = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint\"")
			}
		case "uint8":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Uint8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint8\"")
			}
		case "uint16":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Uint16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint16\"")
			}
		case "uint32":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Uint32 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint32\"")
			}
		case "uint64":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Uint64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint64\"")
			}
		case "float32":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Float32()
				s.Float32 = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float32\"")
			}
		case "float64":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Float64 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float64\"")
			}
		case "string_type":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StringType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"string_type\"")
			}
		case "bool":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Bool = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bool\"")
			}
		case "uuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "time":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "text":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "state":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "bytes":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Base64()
				s.Bytes = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AllTypesUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAllTypesUpdate) {
					name = jsonFieldsNameOfAllTypesUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AllTypesUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AllTypesUpdateState as json.
func (s AllTypesUpdateState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AllTypesUpdateState from json.
func (s *AllTypesUpdateState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllTypesUpdateState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AllTypesUpdateState(v) {
	case AllTypesUpdateStateOn:
		*s = AllTypesUpdateStateOn
	case AllTypesUpdateStateOff:
		*s = AllTypesUpdateStateOff
	default:
		*s = AllTypesUpdateState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AllTypesUpdateState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllTypesUpdateState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoryCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoryCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Readonly.Set {
			e.FieldStart("readonly")
			s.Readonly.Encode(e)
		}
	}
}

var jsonFieldsNameOfCategoryCreate = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes CategoryCreate from json.
func (s *CategoryCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			if err := func() error {
				s.Readonly.Reset()
				if err := s.Readonly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryCreate) {
					name = jsonFieldsNameOfCategoryCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoryCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoryCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoryList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoryList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Readonly.Set {
			e.FieldStart("readonly")
			s.Readonly.Encode(e)
		}
	}
}

var jsonFieldsNameOfCategoryList = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes CategoryList from json.
func (s *CategoryList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			if err := func() error {
				s.Readonly.Reset()
				if err := s.Readonly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryList) {
					name = jsonFieldsNameOfCategoryList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoryList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoryList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoryPetsList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoryPetsList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
}

var jsonFieldsNameOfCategoryPetsList = [6]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "tag_id",
	5: "height",
}

// Decode decodes CategoryPetsList from json.
func (s *CategoryPetsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryPetsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryPetsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryPetsList) {
					name = jsonFieldsNameOfCategoryPetsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoryPetsList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoryPetsList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoryRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoryRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Readonly.Set {
			e.FieldStart("readonly")
			s.Readonly.Encode(e)
		}
	}
}

var jsonFieldsNameOfCategoryRead = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes CategoryRead from json.
func (s *CategoryRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			if err := func() error {
				s.Readonly.Reset()
				if err := s.Readonly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryRead) {
					name = jsonFieldsNameOfCategoryRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoryRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoryRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoryUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoryUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Readonly.Set {
			e.FieldStart("readonly")
			s.Readonly.Encode(e)
		}
	}
}

var jsonFieldsNameOfCategoryUpdate = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes CategoryUpdate from json.
func (s *CategoryUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			if err := func() error {
				s.Readonly.Reset()
				if err := s.Readonly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryUpdate) {
					name = jsonFieldsNameOfCategoryUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoryUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoryUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAllTypesReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAllTypesReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("int")
		e.Int(s.Int)
	}
	{

		e.FieldStart("int8")
		e.Int32(s.Int8)
	}
	{

		e.FieldStart("int16")
		e.Int32(s.Int16)
	}
	{

		e.FieldStart("int32")
		e.Int32(s.Int32)
	}
	{

		e.FieldStart("int64")
		e.Int64(s.Int64)
	}
	{

		e.FieldStart("uint")
		e.Int64(s.Uint)
	}
	{

		e.FieldStart("uint8")
		e.Int32(s.Uint8)
	}
	{

		e.FieldStart("uint16")
		e.Int32(s.Uint16)
	}
	{

		e.FieldStart("uint32")
		e.Int64(s.Uint32)
	}
	{

		e.FieldStart("uint64")
		e.Int64(s.Uint64)
	}
	{

		e.FieldStart("float32")
		e.Float32(s.Float32)
	}
	{

		e.FieldStart("float64")
		e.Float64(s.Float64)
	}
	{

		e.FieldStart("string_type")
		e.Str(s.StringType)
	}
	{

		e.FieldStart("bool")
		e.Bool(s.Bool)
	}
	{

		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{

		e.FieldStart("time")
		json.EncodeDateTime(e, s.Time)
	}
	{

		e.FieldStart("text")
		e.Str(s.Text)
	}
	{

		e.FieldStart("state")
		s.State.Encode(e)
	}
	{

		e.FieldStart("bytes")
		e.Base64(s.Bytes)
	}
}

var jsonFieldsNameOfCreateAllTypesReq = [19]string{
	0:  "int",
	1:  "int8",
	2:  "int16",
	3:  "int32",
	4:  "int64",
	5:  "uint",
	6:  "uint8",
	7:  "uint16",
	8:  "uint32",
	9:  "uint64",
	10: "float32",
	11: "float64",
	12: "string_type",
	13: "bool",
	14: "uuid",
	15: "time",
	16: "text",
	17: "state",
	18: "bytes",
}

// Decode decodes CreateAllTypesReq from json.
func (s *CreateAllTypesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAllTypesReq to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "int":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Int = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int\"")
			}
		case "int8":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Int8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int8\"")
			}
		case "int16":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Int16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int16\"")
			}
		case "int32":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Int32 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int32\"")
			}
		case "int64":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.Int64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int64\"")
			}
		case "uint":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.Uint = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint\"")
			}
		case "uint8":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.Uint8 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint8\"")
			}
		case "uint16":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Uint16 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint16\"")
			}
		case "uint32":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.Uint32 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint32\"")
			}
		case "uint64":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Uint64 = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint64\"")
			}
		case "float32":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.Float32 = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float32\"")
			}
		case "float64":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Float64 = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float64\"")
			}
		case "string_type":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.StringType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"string_type\"")
			}
		case "bool":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Bool = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bool\"")
			}
		case "uuid":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "time":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "text":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "state":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "bytes":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Base64()
				s.Bytes = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateAllTypesReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateAllTypesReq) {
					name = jsonFieldsNameOfCreateAllTypesReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAllTypesReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAllTypesReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAllTypesReqState as json.
func (s CreateAllTypesReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateAllTypesReqState from json.
func (s *CreateAllTypesReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAllTypesReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateAllTypesReqState(v) {
	case CreateAllTypesReqStateOn:
		*s = CreateAllTypesReqStateOn
	case CreateAllTypesReqStateOff:
		*s = CreateAllTypesReqStateOff
	default:
		*s = CreateAllTypesReqState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateAllTypesReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAllTypesReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateCategoryReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateCategoryReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Pets != nil {
			e.FieldStart("pets")
			e.ArrStart()
			for _, elem := range s.Pets {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateCategoryReq = [2]string{
	0: "name",
	1: "pets",
}

// Decode decodes CreateCategoryReq from json.
func (s *CreateCategoryReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCategoryReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "pets":
			if err := func() error {
				s.Pets = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Pets = append(s.Pets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateCategoryReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateCategoryReq) {
					name = jsonFieldsNameOfCreateCategoryReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCategoryReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCategoryReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreatePetReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreatePetReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Categories != nil {
			e.FieldStart("categories")
			e.ArrStart()
			for _, elem := range s.Categories {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{

		e.FieldStart("owner")
		e.Int(s.Owner)
	}
	{
		if s.Friends != nil {
			e.FieldStart("friends")
			e.ArrStart()
			for _, elem := range s.Friends {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreatePetReq = [8]string{
	0: "name",
	1: "weight",
	2: "birthday",
	3: "tag_id",
	4: "height",
	5: "categories",
	6: "owner",
	7: "friends",
}

// Decode decodes CreatePetReq from json.
func (s *CreatePetReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePetReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "categories":
			if err := func() error {
				s.Categories = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Owner = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "friends":
			if err := func() error {
				s.Friends = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Friends = append(s.Friends, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friends\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreatePetReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatePetReq) {
					name = jsonFieldsNameOfCreatePetReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatePetReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePetReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
	{
		if s.Pets != nil {
			e.FieldStart("pets")
			e.ArrStart()
			for _, elem := range s.Pets {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BestFriend.Set {
			e.FieldStart("best_friend")
			s.BestFriend.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateUserReq = [8]string{
	0: "name",
	1: "age",
	2: "height",
	3: "favorite_cat_breed",
	4: "favorite_dog_breed",
	5: "favorite_fish_breed",
	6: "pets",
	7: "best_friend",
}

// Decode decodes CreateUserReq from json.
func (s *CreateUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		case "pets":
			if err := func() error {
				s.Pets = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Pets = append(s.Pets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pets\"")
			}
		case "best_friend":
			if err := func() error {
				s.BestFriend.Reset()
				if err := s.BestFriend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"best_friend\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserReq) {
					name = jsonFieldsNameOfCreateUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserReqFavoriteCatBreed as json.
func (s CreateUserReqFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateUserReqFavoriteCatBreed from json.
func (s *CreateUserReqFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserReqFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserReqFavoriteCatBreed(v) {
	case CreateUserReqFavoriteCatBreedSiamese:
		*s = CreateUserReqFavoriteCatBreedSiamese
	case CreateUserReqFavoriteCatBreedBengal:
		*s = CreateUserReqFavoriteCatBreedBengal
	case CreateUserReqFavoriteCatBreedLion:
		*s = CreateUserReqFavoriteCatBreedLion
	case CreateUserReqFavoriteCatBreedTiger:
		*s = CreateUserReqFavoriteCatBreedTiger
	case CreateUserReqFavoriteCatBreedLeopard:
		*s = CreateUserReqFavoriteCatBreedLeopard
	case CreateUserReqFavoriteCatBreedOther:
		*s = CreateUserReqFavoriteCatBreedOther
	default:
		*s = CreateUserReqFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserReqFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserReqFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserReqFavoriteDogBreed as json.
func (s CreateUserReqFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateUserReqFavoriteDogBreed from json.
func (s *CreateUserReqFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserReqFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserReqFavoriteDogBreed(v) {
	case CreateUserReqFavoriteDogBreedKuro:
		*s = CreateUserReqFavoriteDogBreedKuro
	default:
		*s = CreateUserReqFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserReqFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserReqFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserReqFavoriteFishBreed as json.
func (s CreateUserReqFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateUserReqFavoriteFishBreed from json.
func (s *CreateUserReqFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserReqFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserReqFavoriteFishBreed(v) {
	case CreateUserReqFavoriteFishBreedGold:
		*s = CreateUserReqFavoriteFishBreedGold
	case CreateUserReqFavoriteFishBreedKoi:
		*s = CreateUserReqFavoriteFishBreedKoi
	case CreateUserReqFavoriteFishBreedShark:
		*s = CreateUserReqFavoriteFishBreedShark
	default:
		*s = CreateUserReqFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserReqFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserReqFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListAllTypesOKApplicationJSON as json.
func (s ListAllTypesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []AllTypesList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListAllTypesOKApplicationJSON from json.
func (s *ListAllTypesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAllTypesOKApplicationJSON to nil")
	}
	var unwrapped []AllTypesList
	if err := func() error {
		unwrapped = make([]AllTypesList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AllTypesList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListAllTypesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListAllTypesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAllTypesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListCategoryOKApplicationJSON as json.
func (s ListCategoryOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CategoryList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListCategoryOKApplicationJSON from json.
func (s *ListCategoryOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListCategoryOKApplicationJSON to nil")
	}
	var unwrapped []CategoryList
	if err := func() error {
		unwrapped = make([]CategoryList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CategoryList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListCategoryOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListCategoryOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListCategoryOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListCategoryPetsOKApplicationJSON as json.
func (s ListCategoryPetsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CategoryPetsList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListCategoryPetsOKApplicationJSON from json.
func (s *ListCategoryPetsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListCategoryPetsOKApplicationJSON to nil")
	}
	var unwrapped []CategoryPetsList
	if err := func() error {
		unwrapped = make([]CategoryPetsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CategoryPetsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListCategoryPetsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListCategoryPetsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListCategoryPetsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListPetCategoriesOKApplicationJSON as json.
func (s ListPetCategoriesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PetCategoriesList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListPetCategoriesOKApplicationJSON from json.
func (s *ListPetCategoriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPetCategoriesOKApplicationJSON to nil")
	}
	var unwrapped []PetCategoriesList
	if err := func() error {
		unwrapped = make([]PetCategoriesList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PetCategoriesList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListPetCategoriesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListPetCategoriesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListPetCategoriesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListPetFriendsOKApplicationJSON as json.
func (s ListPetFriendsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PetFriendsList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListPetFriendsOKApplicationJSON from json.
func (s *ListPetFriendsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPetFriendsOKApplicationJSON to nil")
	}
	var unwrapped []PetFriendsList
	if err := func() error {
		unwrapped = make([]PetFriendsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PetFriendsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListPetFriendsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListPetFriendsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListPetFriendsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListPetOKApplicationJSON as json.
func (s ListPetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PetList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListPetOKApplicationJSON from json.
func (s *ListPetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPetOKApplicationJSON to nil")
	}
	var unwrapped []PetList
	if err := func() error {
		unwrapped = make([]PetList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PetList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListPetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListPetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListPetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListUserOKApplicationJSON as json.
func (s ListUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []UserList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListUserOKApplicationJSON from json.
func (s *ListUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserOKApplicationJSON to nil")
	}
	var unwrapped []UserList
	if err := func() error {
		unwrapped = make([]UserList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListUserOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListUserOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListUserPetsOKApplicationJSON as json.
func (s ListUserPetsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []UserPetsList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListUserPetsOKApplicationJSON from json.
func (s *ListUserPetsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUserPetsOKApplicationJSON to nil")
	}
	var unwrapped []UserPetsList
	if err := func() error {
		unwrapped = make([]UserPetsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserPetsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUserPetsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListUserPetsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListUserPetsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserReqFavoriteDogBreed as json.
func (o OptCreateUserReqFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateUserReqFavoriteDogBreed from json.
func (o *OptCreateUserReqFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateUserReqFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateUserReqFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateUserReqFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserReqFavoriteFishBreed as json.
func (o OptCreateUserReqFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateUserReqFavoriteFishBreed from json.
func (o *OptCreateUserReqFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateUserReqFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateUserReqFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateUserReqFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetCreateOwnerFavoriteDogBreed as json.
func (o OptPetCreateOwnerFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PetCreateOwnerFavoriteDogBreed from json.
func (o *OptPetCreateOwnerFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPetCreateOwnerFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPetCreateOwnerFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPetCreateOwnerFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetCreateOwnerFavoriteFishBreed as json.
func (o OptPetCreateOwnerFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PetCreateOwnerFavoriteFishBreed from json.
func (o *OptPetCreateOwnerFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPetCreateOwnerFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPetCreateOwnerFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPetCreateOwnerFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetOwnerReadFavoriteDogBreed as json.
func (o OptPetOwnerReadFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PetOwnerReadFavoriteDogBreed from json.
func (o *OptPetOwnerReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPetOwnerReadFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPetOwnerReadFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPetOwnerReadFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetOwnerReadFavoriteFishBreed as json.
func (o OptPetOwnerReadFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PetOwnerReadFavoriteFishBreed from json.
func (o *OptPetOwnerReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPetOwnerReadFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPetOwnerReadFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPetOwnerReadFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAllTypesReqState as json.
func (o OptUpdateAllTypesReqState) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateAllTypesReqState from json.
func (o *OptUpdateAllTypesReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateAllTypesReqState to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateAllTypesReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateAllTypesReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserReqFavoriteCatBreed as json.
func (o OptUpdateUserReqFavoriteCatBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserReqFavoriteCatBreed from json.
func (o *OptUpdateUserReqFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserReqFavoriteCatBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUserReqFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUserReqFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserReqFavoriteDogBreed as json.
func (o OptUpdateUserReqFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserReqFavoriteDogBreed from json.
func (o *OptUpdateUserReqFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserReqFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUserReqFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUserReqFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserReqFavoriteFishBreed as json.
func (o OptUpdateUserReqFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserReqFavoriteFishBreed from json.
func (o *OptUpdateUserReqFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserReqFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUserReqFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUserReqFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBestFriendReadFavoriteDogBreed as json.
func (o OptUserBestFriendReadFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserBestFriendReadFavoriteDogBreed from json.
func (o *OptUserBestFriendReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserBestFriendReadFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserBestFriendReadFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserBestFriendReadFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBestFriendReadFavoriteFishBreed as json.
func (o OptUserBestFriendReadFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserBestFriendReadFavoriteFishBreed from json.
func (o *OptUserBestFriendReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserBestFriendReadFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserBestFriendReadFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserBestFriendReadFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserCreateFavoriteDogBreed as json.
func (o OptUserCreateFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserCreateFavoriteDogBreed from json.
func (o *OptUserCreateFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserCreateFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserCreateFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserCreateFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserCreateFavoriteFishBreed as json.
func (o OptUserCreateFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserCreateFavoriteFishBreed from json.
func (o *OptUserCreateFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserCreateFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserCreateFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserCreateFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserListFavoriteDogBreed as json.
func (o OptUserListFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserListFavoriteDogBreed from json.
func (o *OptUserListFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserListFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserListFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserListFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserListFavoriteFishBreed as json.
func (o OptUserListFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserListFavoriteFishBreed from json.
func (o *OptUserListFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserListFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserListFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserListFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserReadFavoriteDogBreed as json.
func (o OptUserReadFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserReadFavoriteDogBreed from json.
func (o *OptUserReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserReadFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserReadFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserReadFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserReadFavoriteFishBreed as json.
func (o OptUserReadFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserReadFavoriteFishBreed from json.
func (o *OptUserReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserReadFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserReadFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserReadFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserUpdateFavoriteDogBreed as json.
func (o OptUserUpdateFavoriteDogBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserUpdateFavoriteDogBreed from json.
func (o *OptUserUpdateFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserUpdateFavoriteDogBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserUpdateFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserUpdateFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserUpdateFavoriteFishBreed as json.
func (o OptUserUpdateFavoriteFishBreed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserUpdateFavoriteFishBreed from json.
func (o *OptUserUpdateFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserUpdateFavoriteFishBreed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserUpdateFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserUpdateFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetCategoriesList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetCategoriesList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Readonly.Set {
			e.FieldStart("readonly")
			s.Readonly.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetCategoriesList = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes PetCategoriesList from json.
func (s *PetCategoriesList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCategoriesList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			if err := func() error {
				s.Readonly.Reset()
				if err := s.Readonly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetCategoriesList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCategoriesList) {
					name = jsonFieldsNameOfPetCategoriesList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetCategoriesList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetCategoriesList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Categories != nil {
			e.FieldStart("categories")
			e.ArrStart()
			for _, elem := range s.Categories {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{

		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
}

var jsonFieldsNameOfPetCreate = [8]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "tag_id",
	5: "height",
	6: "categories",
	7: "owner",
}

// Decode decodes PetCreate from json.
func (s *PetCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "categories":
			if err := func() error {
				s.Categories = make([]PetCreateCategories, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PetCreateCategories
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCreate) {
					name = jsonFieldsNameOfPetCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetCreateCategories) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetCreateCategories) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Readonly.Set {
			e.FieldStart("readonly")
			s.Readonly.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetCreateCategories = [3]string{
	0: "id",
	1: "name",
	2: "readonly",
}

// Decode decodes PetCreateCategories from json.
func (s *PetCreateCategories) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateCategories to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readonly":
			if err := func() error {
				s.Readonly.Reset()
				if err := s.Readonly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readonly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetCreateCategories")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCreateCategories) {
					name = jsonFieldsNameOfPetCreateCategories[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetCreateCategories) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetCreateCategories) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetCreateOwner) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetCreateOwner) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetCreateOwner = [7]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_dog_breed",
	6: "favorite_fish_breed",
}

// Decode decodes PetCreateOwner from json.
func (s *PetCreateOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateOwner to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetCreateOwner")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetCreateOwner) {
					name = jsonFieldsNameOfPetCreateOwner[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetCreateOwner) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetCreateOwner) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetCreateOwnerFavoriteCatBreed as json.
func (s PetCreateOwnerFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetCreateOwnerFavoriteCatBreed from json.
func (s *PetCreateOwnerFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateOwnerFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetCreateOwnerFavoriteCatBreed(v) {
	case PetCreateOwnerFavoriteCatBreedSiamese:
		*s = PetCreateOwnerFavoriteCatBreedSiamese
	case PetCreateOwnerFavoriteCatBreedBengal:
		*s = PetCreateOwnerFavoriteCatBreedBengal
	case PetCreateOwnerFavoriteCatBreedLion:
		*s = PetCreateOwnerFavoriteCatBreedLion
	case PetCreateOwnerFavoriteCatBreedTiger:
		*s = PetCreateOwnerFavoriteCatBreedTiger
	case PetCreateOwnerFavoriteCatBreedLeopard:
		*s = PetCreateOwnerFavoriteCatBreedLeopard
	case PetCreateOwnerFavoriteCatBreedOther:
		*s = PetCreateOwnerFavoriteCatBreedOther
	default:
		*s = PetCreateOwnerFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetCreateOwnerFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetCreateOwnerFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetCreateOwnerFavoriteDogBreed as json.
func (s PetCreateOwnerFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetCreateOwnerFavoriteDogBreed from json.
func (s *PetCreateOwnerFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateOwnerFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetCreateOwnerFavoriteDogBreed(v) {
	case PetCreateOwnerFavoriteDogBreedKuro:
		*s = PetCreateOwnerFavoriteDogBreedKuro
	default:
		*s = PetCreateOwnerFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetCreateOwnerFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetCreateOwnerFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetCreateOwnerFavoriteFishBreed as json.
func (s PetCreateOwnerFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetCreateOwnerFavoriteFishBreed from json.
func (s *PetCreateOwnerFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetCreateOwnerFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetCreateOwnerFavoriteFishBreed(v) {
	case PetCreateOwnerFavoriteFishBreedGold:
		*s = PetCreateOwnerFavoriteFishBreedGold
	case PetCreateOwnerFavoriteFishBreedKoi:
		*s = PetCreateOwnerFavoriteFishBreedKoi
	case PetCreateOwnerFavoriteFishBreedShark:
		*s = PetCreateOwnerFavoriteFishBreedShark
	default:
		*s = PetCreateOwnerFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetCreateOwnerFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetCreateOwnerFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetFriendsList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetFriendsList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetFriendsList = [6]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "tag_id",
	5: "height",
}

// Decode decodes PetFriendsList from json.
func (s *PetFriendsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetFriendsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetFriendsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetFriendsList) {
					name = jsonFieldsNameOfPetFriendsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetFriendsList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetFriendsList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetList = [6]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "tag_id",
	5: "height",
}

// Decode decodes PetList from json.
func (s *PetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetList) {
					name = jsonFieldsNameOfPetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetOwnerRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetOwnerRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetOwnerRead = [7]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_dog_breed",
	6: "favorite_fish_breed",
}

// Decode decodes PetOwnerRead from json.
func (s *PetOwnerRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetOwnerRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetOwnerRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetOwnerRead) {
					name = jsonFieldsNameOfPetOwnerRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetOwnerRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetOwnerRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetOwnerReadFavoriteCatBreed as json.
func (s PetOwnerReadFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetOwnerReadFavoriteCatBreed from json.
func (s *PetOwnerReadFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetOwnerReadFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetOwnerReadFavoriteCatBreed(v) {
	case PetOwnerReadFavoriteCatBreedSiamese:
		*s = PetOwnerReadFavoriteCatBreedSiamese
	case PetOwnerReadFavoriteCatBreedBengal:
		*s = PetOwnerReadFavoriteCatBreedBengal
	case PetOwnerReadFavoriteCatBreedLion:
		*s = PetOwnerReadFavoriteCatBreedLion
	case PetOwnerReadFavoriteCatBreedTiger:
		*s = PetOwnerReadFavoriteCatBreedTiger
	case PetOwnerReadFavoriteCatBreedLeopard:
		*s = PetOwnerReadFavoriteCatBreedLeopard
	case PetOwnerReadFavoriteCatBreedOther:
		*s = PetOwnerReadFavoriteCatBreedOther
	default:
		*s = PetOwnerReadFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetOwnerReadFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetOwnerReadFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetOwnerReadFavoriteDogBreed as json.
func (s PetOwnerReadFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetOwnerReadFavoriteDogBreed from json.
func (s *PetOwnerReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetOwnerReadFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetOwnerReadFavoriteDogBreed(v) {
	case PetOwnerReadFavoriteDogBreedKuro:
		*s = PetOwnerReadFavoriteDogBreedKuro
	default:
		*s = PetOwnerReadFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetOwnerReadFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetOwnerReadFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PetOwnerReadFavoriteFishBreed as json.
func (s PetOwnerReadFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PetOwnerReadFavoriteFishBreed from json.
func (s *PetOwnerReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetOwnerReadFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PetOwnerReadFavoriteFishBreed(v) {
	case PetOwnerReadFavoriteFishBreedGold:
		*s = PetOwnerReadFavoriteFishBreedGold
	case PetOwnerReadFavoriteFishBreedKoi:
		*s = PetOwnerReadFavoriteFishBreedKoi
	case PetOwnerReadFavoriteFishBreedShark:
		*s = PetOwnerReadFavoriteFishBreedShark
	default:
		*s = PetOwnerReadFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PetOwnerReadFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetOwnerReadFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetRead = [6]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "tag_id",
	5: "height",
}

// Decode decodes PetRead from json.
func (s *PetRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetRead) {
					name = jsonFieldsNameOfPetRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PetUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PetUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
}

var jsonFieldsNameOfPetUpdate = [6]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "tag_id",
	5: "height",
}

// Decode decodes PetUpdate from json.
func (s *PetUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PetUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PetUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPetUpdate) {
					name = jsonFieldsNameOfPetUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PetUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PetUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R400) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R400) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR400 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R400 from json.
func (s *R400) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R400 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R400")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR400) {
					name = jsonFieldsNameOfR400[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R400) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R400) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R404) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R404) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR404 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R404 from json.
func (s *R404) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R404 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R404")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR404) {
					name = jsonFieldsNameOfR404[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R404) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R404) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R409) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R409) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR409 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R409 from json.
func (s *R409) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R409 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R409")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR409) {
					name = jsonFieldsNameOfR409[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R409) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R409) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R500) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R500) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR500 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R500 from json.
func (s *R500) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R500 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R500")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR500) {
					name = jsonFieldsNameOfR500[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R500) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R500) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateAllTypesReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateAllTypesReq) encodeFields(e *jx.Encoder) {
	{
		if s.Int.Set {
			e.FieldStart("int")
			s.Int.Encode(e)
		}
	}
	{
		if s.Int8.Set {
			e.FieldStart("int8")
			s.Int8.Encode(e)
		}
	}
	{
		if s.Int16.Set {
			e.FieldStart("int16")
			s.Int16.Encode(e)
		}
	}
	{
		if s.Int32.Set {
			e.FieldStart("int32")
			s.Int32.Encode(e)
		}
	}
	{
		if s.Int64.Set {
			e.FieldStart("int64")
			s.Int64.Encode(e)
		}
	}
	{
		if s.Uint.Set {
			e.FieldStart("uint")
			s.Uint.Encode(e)
		}
	}
	{
		if s.Uint8.Set {
			e.FieldStart("uint8")
			s.Uint8.Encode(e)
		}
	}
	{
		if s.Uint16.Set {
			e.FieldStart("uint16")
			s.Uint16.Encode(e)
		}
	}
	{
		if s.Uint32.Set {
			e.FieldStart("uint32")
			s.Uint32.Encode(e)
		}
	}
	{
		if s.Uint64.Set {
			e.FieldStart("uint64")
			s.Uint64.Encode(e)
		}
	}
	{
		if s.Float32.Set {
			e.FieldStart("float32")
			s.Float32.Encode(e)
		}
	}
	{
		if s.Float64.Set {
			e.FieldStart("float64")
			s.Float64.Encode(e)
		}
	}
	{
		if s.StringType.Set {
			e.FieldStart("string_type")
			s.StringType.Encode(e)
		}
	}
	{
		if s.Bool.Set {
			e.FieldStart("bool")
			s.Bool.Encode(e)
		}
	}
	{
		if s.UUID.Set {
			e.FieldStart("uuid")
			s.UUID.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("time")
			s.Time.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{

		e.FieldStart("bytes")
		e.Base64(s.Bytes)
	}
}

var jsonFieldsNameOfUpdateAllTypesReq = [19]string{
	0:  "int",
	1:  "int8",
	2:  "int16",
	3:  "int32",
	4:  "int64",
	5:  "uint",
	6:  "uint8",
	7:  "uint16",
	8:  "uint32",
	9:  "uint64",
	10: "float32",
	11: "float64",
	12: "string_type",
	13: "bool",
	14: "uuid",
	15: "time",
	16: "text",
	17: "state",
	18: "bytes",
}

// Decode decodes UpdateAllTypesReq from json.
func (s *UpdateAllTypesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAllTypesReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "int":
			if err := func() error {
				s.Int.Reset()
				if err := s.Int.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int\"")
			}
		case "int8":
			if err := func() error {
				s.Int8.Reset()
				if err := s.Int8.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int8\"")
			}
		case "int16":
			if err := func() error {
				s.Int16.Reset()
				if err := s.Int16.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int16\"")
			}
		case "int32":
			if err := func() error {
				s.Int32.Reset()
				if err := s.Int32.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int32\"")
			}
		case "int64":
			if err := func() error {
				s.Int64.Reset()
				if err := s.Int64.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int64\"")
			}
		case "uint":
			if err := func() error {
				s.Uint.Reset()
				if err := s.Uint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint\"")
			}
		case "uint8":
			if err := func() error {
				s.Uint8.Reset()
				if err := s.Uint8.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint8\"")
			}
		case "uint16":
			if err := func() error {
				s.Uint16.Reset()
				if err := s.Uint16.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint16\"")
			}
		case "uint32":
			if err := func() error {
				s.Uint32.Reset()
				if err := s.Uint32.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint32\"")
			}
		case "uint64":
			if err := func() error {
				s.Uint64.Reset()
				if err := s.Uint64.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uint64\"")
			}
		case "float32":
			if err := func() error {
				s.Float32.Reset()
				if err := s.Float32.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float32\"")
			}
		case "float64":
			if err := func() error {
				s.Float64.Reset()
				if err := s.Float64.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"float64\"")
			}
		case "string_type":
			if err := func() error {
				s.StringType.Reset()
				if err := s.StringType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"string_type\"")
			}
		case "bool":
			if err := func() error {
				s.Bool.Reset()
				if err := s.Bool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bool\"")
			}
		case "uuid":
			if err := func() error {
				s.UUID.Reset()
				if err := s.UUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "bytes":
			if err := func() error {
				v, err := d.Base64()
				s.Bytes = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateAllTypesReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateAllTypesReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAllTypesReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAllTypesReqState as json.
func (s UpdateAllTypesReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateAllTypesReqState from json.
func (s *UpdateAllTypesReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAllTypesReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateAllTypesReqState(v) {
	case UpdateAllTypesReqStateOn:
		*s = UpdateAllTypesReqStateOn
	case UpdateAllTypesReqStateOff:
		*s = UpdateAllTypesReqStateOff
	default:
		*s = UpdateAllTypesReqState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateAllTypesReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAllTypesReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCategoryReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCategoryReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Pets != nil {
			e.FieldStart("pets")
			e.ArrStart()
			for _, elem := range s.Pets {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateCategoryReq = [2]string{
	0: "name",
	1: "pets",
}

// Decode decodes UpdateCategoryReq from json.
func (s *UpdateCategoryReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCategoryReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "pets":
			if err := func() error {
				s.Pets = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Pets = append(s.Pets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCategoryReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCategoryReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCategoryReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePetReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePetReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Categories != nil {
			e.FieldStart("categories")
			e.ArrStart()
			for _, elem := range s.Categories {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Owner.Set {
			e.FieldStart("owner")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Friends != nil {
			e.FieldStart("friends")
			e.ArrStart()
			for _, elem := range s.Friends {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdatePetReq = [8]string{
	0: "name",
	1: "weight",
	2: "birthday",
	3: "tag_id",
	4: "height",
	5: "categories",
	6: "owner",
	7: "friends",
}

// Decode decodes UpdatePetReq from json.
func (s *UpdatePetReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePetReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "categories":
			if err := func() error {
				s.Categories = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "friends":
			if err := func() error {
				s.Friends = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Friends = append(s.Friends, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friends\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePetReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePetReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePetReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateUserReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Age.Set {
			e.FieldStart("age")
			s.Age.Encode(e)
		}
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.FavoriteCatBreed.Set {
			e.FieldStart("favorite_cat_breed")
			s.FavoriteCatBreed.Encode(e)
		}
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
	{
		if s.Pets != nil {
			e.FieldStart("pets")
			e.ArrStart()
			for _, elem := range s.Pets {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BestFriend.Set {
			e.FieldStart("best_friend")
			s.BestFriend.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateUserReq = [8]string{
	0: "name",
	1: "age",
	2: "height",
	3: "favorite_cat_breed",
	4: "favorite_dog_breed",
	5: "favorite_fish_breed",
	6: "pets",
	7: "best_friend",
}

// Decode decodes UpdateUserReq from json.
func (s *UpdateUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			if err := func() error {
				s.Age.Reset()
				if err := s.Age.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			if err := func() error {
				s.FavoriteCatBreed.Reset()
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		case "pets":
			if err := func() error {
				s.Pets = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Pets = append(s.Pets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pets\"")
			}
		case "best_friend":
			if err := func() error {
				s.BestFriend.Reset()
				if err := s.BestFriend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"best_friend\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUserReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserReqFavoriteCatBreed as json.
func (s UpdateUserReqFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateUserReqFavoriteCatBreed from json.
func (s *UpdateUserReqFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserReqFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserReqFavoriteCatBreed(v) {
	case UpdateUserReqFavoriteCatBreedSiamese:
		*s = UpdateUserReqFavoriteCatBreedSiamese
	case UpdateUserReqFavoriteCatBreedBengal:
		*s = UpdateUserReqFavoriteCatBreedBengal
	case UpdateUserReqFavoriteCatBreedLion:
		*s = UpdateUserReqFavoriteCatBreedLion
	case UpdateUserReqFavoriteCatBreedTiger:
		*s = UpdateUserReqFavoriteCatBreedTiger
	case UpdateUserReqFavoriteCatBreedLeopard:
		*s = UpdateUserReqFavoriteCatBreedLeopard
	case UpdateUserReqFavoriteCatBreedOther:
		*s = UpdateUserReqFavoriteCatBreedOther
	default:
		*s = UpdateUserReqFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUserReqFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserReqFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserReqFavoriteDogBreed as json.
func (s UpdateUserReqFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateUserReqFavoriteDogBreed from json.
func (s *UpdateUserReqFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserReqFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserReqFavoriteDogBreed(v) {
	case UpdateUserReqFavoriteDogBreedKuro:
		*s = UpdateUserReqFavoriteDogBreedKuro
	default:
		*s = UpdateUserReqFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUserReqFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserReqFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserReqFavoriteFishBreed as json.
func (s UpdateUserReqFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateUserReqFavoriteFishBreed from json.
func (s *UpdateUserReqFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserReqFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserReqFavoriteFishBreed(v) {
	case UpdateUserReqFavoriteFishBreedGold:
		*s = UpdateUserReqFavoriteFishBreedGold
	case UpdateUserReqFavoriteFishBreedKoi:
		*s = UpdateUserReqFavoriteFishBreedKoi
	case UpdateUserReqFavoriteFishBreedShark:
		*s = UpdateUserReqFavoriteFishBreedShark
	default:
		*s = UpdateUserReqFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUserReqFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserReqFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserBestFriendRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserBestFriendRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserBestFriendRead = [7]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_dog_breed",
	6: "favorite_fish_breed",
}

// Decode decodes UserBestFriendRead from json.
func (s *UserBestFriendRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBestFriendRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserBestFriendRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserBestFriendRead) {
					name = jsonFieldsNameOfUserBestFriendRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserBestFriendRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserBestFriendRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBestFriendReadFavoriteCatBreed as json.
func (s UserBestFriendReadFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserBestFriendReadFavoriteCatBreed from json.
func (s *UserBestFriendReadFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBestFriendReadFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserBestFriendReadFavoriteCatBreed(v) {
	case UserBestFriendReadFavoriteCatBreedSiamese:
		*s = UserBestFriendReadFavoriteCatBreedSiamese
	case UserBestFriendReadFavoriteCatBreedBengal:
		*s = UserBestFriendReadFavoriteCatBreedBengal
	case UserBestFriendReadFavoriteCatBreedLion:
		*s = UserBestFriendReadFavoriteCatBreedLion
	case UserBestFriendReadFavoriteCatBreedTiger:
		*s = UserBestFriendReadFavoriteCatBreedTiger
	case UserBestFriendReadFavoriteCatBreedLeopard:
		*s = UserBestFriendReadFavoriteCatBreedLeopard
	case UserBestFriendReadFavoriteCatBreedOther:
		*s = UserBestFriendReadFavoriteCatBreedOther
	default:
		*s = UserBestFriendReadFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserBestFriendReadFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserBestFriendReadFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBestFriendReadFavoriteDogBreed as json.
func (s UserBestFriendReadFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserBestFriendReadFavoriteDogBreed from json.
func (s *UserBestFriendReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBestFriendReadFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserBestFriendReadFavoriteDogBreed(v) {
	case UserBestFriendReadFavoriteDogBreedKuro:
		*s = UserBestFriendReadFavoriteDogBreedKuro
	default:
		*s = UserBestFriendReadFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserBestFriendReadFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserBestFriendReadFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBestFriendReadFavoriteFishBreed as json.
func (s UserBestFriendReadFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserBestFriendReadFavoriteFishBreed from json.
func (s *UserBestFriendReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBestFriendReadFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserBestFriendReadFavoriteFishBreed(v) {
	case UserBestFriendReadFavoriteFishBreedGold:
		*s = UserBestFriendReadFavoriteFishBreedGold
	case UserBestFriendReadFavoriteFishBreedKoi:
		*s = UserBestFriendReadFavoriteFishBreedKoi
	case UserBestFriendReadFavoriteFishBreedShark:
		*s = UserBestFriendReadFavoriteFishBreedShark
	default:
		*s = UserBestFriendReadFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserBestFriendReadFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserBestFriendReadFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserCreate = [7]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_dog_breed",
	6: "favorite_fish_breed",
}

// Decode decodes UserCreate from json.
func (s *UserCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserCreate) {
					name = jsonFieldsNameOfUserCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserCreateFavoriteCatBreed as json.
func (s UserCreateFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserCreateFavoriteCatBreed from json.
func (s *UserCreateFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreateFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserCreateFavoriteCatBreed(v) {
	case UserCreateFavoriteCatBreedSiamese:
		*s = UserCreateFavoriteCatBreedSiamese
	case UserCreateFavoriteCatBreedBengal:
		*s = UserCreateFavoriteCatBreedBengal
	case UserCreateFavoriteCatBreedLion:
		*s = UserCreateFavoriteCatBreedLion
	case UserCreateFavoriteCatBreedTiger:
		*s = UserCreateFavoriteCatBreedTiger
	case UserCreateFavoriteCatBreedLeopard:
		*s = UserCreateFavoriteCatBreedLeopard
	case UserCreateFavoriteCatBreedOther:
		*s = UserCreateFavoriteCatBreedOther
	default:
		*s = UserCreateFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserCreateFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserCreateFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserCreateFavoriteDogBreed as json.
func (s UserCreateFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserCreateFavoriteDogBreed from json.
func (s *UserCreateFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreateFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserCreateFavoriteDogBreed(v) {
	case UserCreateFavoriteDogBreedKuro:
		*s = UserCreateFavoriteDogBreedKuro
	default:
		*s = UserCreateFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserCreateFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserCreateFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserCreateFavoriteFishBreed as json.
func (s UserCreateFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserCreateFavoriteFishBreed from json.
func (s *UserCreateFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreateFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserCreateFavoriteFishBreed(v) {
	case UserCreateFavoriteFishBreedGold:
		*s = UserCreateFavoriteFishBreedGold
	case UserCreateFavoriteFishBreedKoi:
		*s = UserCreateFavoriteFishBreedKoi
	case UserCreateFavoriteFishBreedShark:
		*s = UserCreateFavoriteFishBreedShark
	default:
		*s = UserCreateFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserCreateFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserCreateFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserList = [7]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_dog_breed",
	6: "favorite_fish_breed",
}

// Decode decodes UserList from json.
func (s *UserList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserList) {
					name = jsonFieldsNameOfUserList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserListFavoriteCatBreed as json.
func (s UserListFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserListFavoriteCatBreed from json.
func (s *UserListFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserListFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserListFavoriteCatBreed(v) {
	case UserListFavoriteCatBreedSiamese:
		*s = UserListFavoriteCatBreedSiamese
	case UserListFavoriteCatBreedBengal:
		*s = UserListFavoriteCatBreedBengal
	case UserListFavoriteCatBreedLion:
		*s = UserListFavoriteCatBreedLion
	case UserListFavoriteCatBreedTiger:
		*s = UserListFavoriteCatBreedTiger
	case UserListFavoriteCatBreedLeopard:
		*s = UserListFavoriteCatBreedLeopard
	case UserListFavoriteCatBreedOther:
		*s = UserListFavoriteCatBreedOther
	default:
		*s = UserListFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserListFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserListFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserListFavoriteDogBreed as json.
func (s UserListFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserListFavoriteDogBreed from json.
func (s *UserListFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserListFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserListFavoriteDogBreed(v) {
	case UserListFavoriteDogBreedKuro:
		*s = UserListFavoriteDogBreedKuro
	default:
		*s = UserListFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserListFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserListFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserListFavoriteFishBreed as json.
func (s UserListFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserListFavoriteFishBreed from json.
func (s *UserListFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserListFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserListFavoriteFishBreed(v) {
	case UserListFavoriteFishBreedGold:
		*s = UserListFavoriteFishBreedGold
	case UserListFavoriteFishBreedKoi:
		*s = UserListFavoriteFishBreedKoi
	case UserListFavoriteFishBreedShark:
		*s = UserListFavoriteFishBreedShark
	default:
		*s = UserListFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserListFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserListFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserPetsList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserPetsList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("tag_id")
		e.Base64(s.TagID)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserPetsList = [6]string{
	0: "id",
	1: "name",
	2: "weight",
	3: "birthday",
	4: "tag_id",
	5: "height",
}

// Decode decodes UserPetsList from json.
func (s *UserPetsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserPetsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "tag_id":
			if err := func() error {
				v, err := d.Base64()
				s.TagID = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_id\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserPetsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserPetsList) {
					name = jsonFieldsNameOfUserPetsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserPetsList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserPetsList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserRead = [7]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_dog_breed",
	6: "favorite_fish_breed",
}

// Decode decodes UserRead from json.
func (s *UserRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserRead) {
					name = jsonFieldsNameOfUserRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserReadFavoriteCatBreed as json.
func (s UserReadFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserReadFavoriteCatBreed from json.
func (s *UserReadFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserReadFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserReadFavoriteCatBreed(v) {
	case UserReadFavoriteCatBreedSiamese:
		*s = UserReadFavoriteCatBreedSiamese
	case UserReadFavoriteCatBreedBengal:
		*s = UserReadFavoriteCatBreedBengal
	case UserReadFavoriteCatBreedLion:
		*s = UserReadFavoriteCatBreedLion
	case UserReadFavoriteCatBreedTiger:
		*s = UserReadFavoriteCatBreedTiger
	case UserReadFavoriteCatBreedLeopard:
		*s = UserReadFavoriteCatBreedLeopard
	case UserReadFavoriteCatBreedOther:
		*s = UserReadFavoriteCatBreedOther
	default:
		*s = UserReadFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserReadFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserReadFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserReadFavoriteDogBreed as json.
func (s UserReadFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserReadFavoriteDogBreed from json.
func (s *UserReadFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserReadFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserReadFavoriteDogBreed(v) {
	case UserReadFavoriteDogBreedKuro:
		*s = UserReadFavoriteDogBreedKuro
	default:
		*s = UserReadFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserReadFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserReadFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserReadFavoriteFishBreed as json.
func (s UserReadFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserReadFavoriteFishBreed from json.
func (s *UserReadFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserReadFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserReadFavoriteFishBreed(v) {
	case UserReadFavoriteFishBreedGold:
		*s = UserReadFavoriteFishBreedGold
	case UserReadFavoriteFishBreedKoi:
		*s = UserReadFavoriteFishBreedKoi
	case UserReadFavoriteFishBreedShark:
		*s = UserReadFavoriteFishBreedShark
	default:
		*s = UserReadFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserReadFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserReadFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Int(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("age")
		e.Int64(s.Age)
	}
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{

		e.FieldStart("favorite_cat_breed")
		s.FavoriteCatBreed.Encode(e)
	}
	{
		if s.FavoriteDogBreed.Set {
			e.FieldStart("favorite_dog_breed")
			s.FavoriteDogBreed.Encode(e)
		}
	}
	{
		if s.FavoriteFishBreed.Set {
			e.FieldStart("favorite_fish_breed")
			s.FavoriteFishBreed.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserUpdate = [7]string{
	0: "id",
	1: "name",
	2: "age",
	3: "height",
	4: "favorite_cat_breed",
	5: "favorite_dog_breed",
	6: "favorite_fish_breed",
}

// Decode decodes UserUpdate from json.
func (s *UserUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Age = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "favorite_cat_breed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FavoriteCatBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_cat_breed\"")
			}
		case "favorite_dog_breed":
			if err := func() error {
				s.FavoriteDogBreed.Reset()
				if err := s.FavoriteDogBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_dog_breed\"")
			}
		case "favorite_fish_breed":
			if err := func() error {
				s.FavoriteFishBreed.Reset()
				if err := s.FavoriteFishBreed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite_fish_breed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserUpdate) {
					name = jsonFieldsNameOfUserUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserUpdateFavoriteCatBreed as json.
func (s UserUpdateFavoriteCatBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserUpdateFavoriteCatBreed from json.
func (s *UserUpdateFavoriteCatBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUpdateFavoriteCatBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserUpdateFavoriteCatBreed(v) {
	case UserUpdateFavoriteCatBreedSiamese:
		*s = UserUpdateFavoriteCatBreedSiamese
	case UserUpdateFavoriteCatBreedBengal:
		*s = UserUpdateFavoriteCatBreedBengal
	case UserUpdateFavoriteCatBreedLion:
		*s = UserUpdateFavoriteCatBreedLion
	case UserUpdateFavoriteCatBreedTiger:
		*s = UserUpdateFavoriteCatBreedTiger
	case UserUpdateFavoriteCatBreedLeopard:
		*s = UserUpdateFavoriteCatBreedLeopard
	case UserUpdateFavoriteCatBreedOther:
		*s = UserUpdateFavoriteCatBreedOther
	default:
		*s = UserUpdateFavoriteCatBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserUpdateFavoriteCatBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserUpdateFavoriteCatBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserUpdateFavoriteDogBreed as json.
func (s UserUpdateFavoriteDogBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserUpdateFavoriteDogBreed from json.
func (s *UserUpdateFavoriteDogBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUpdateFavoriteDogBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserUpdateFavoriteDogBreed(v) {
	case UserUpdateFavoriteDogBreedKuro:
		*s = UserUpdateFavoriteDogBreedKuro
	default:
		*s = UserUpdateFavoriteDogBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserUpdateFavoriteDogBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserUpdateFavoriteDogBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserUpdateFavoriteFishBreed as json.
func (s UserUpdateFavoriteFishBreed) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserUpdateFavoriteFishBreed from json.
func (s *UserUpdateFavoriteFishBreed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUpdateFavoriteFishBreed to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserUpdateFavoriteFishBreed(v) {
	case UserUpdateFavoriteFishBreedGold:
		*s = UserUpdateFavoriteFishBreedGold
	case UserUpdateFavoriteFishBreedKoi:
		*s = UserUpdateFavoriteFishBreedKoi
	case UserUpdateFavoriteFishBreedShark:
		*s = UserUpdateFavoriteFishBreedShark
	default:
		*s = UserUpdateFavoriteFishBreed(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserUpdateFavoriteFishBreed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserUpdateFavoriteFishBreed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
